<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Law Review Comment Viewer - v44</title>

<script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
body {
  margin: 0;
  padding: 0;
  font-family: Helvetica, Arial, sans-serif;
  background: #f8f9fa;
}
[contenteditable] { outline: none; }
[contenteditable]:focus { background-color: #f0f0f0; }

::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #f1f1f1; }
::-webkit-scrollbar-thumb { background: #6b7280; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #4b5563; }

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
.fade-in { animation: fadeIn 0.2s ease-in; }
.save-indicator { transition: opacity 0.3s ease; }
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
console.log("Law Review Add-in Version 44 - Compact layout with Notre Dame color palette");

const { useState, useEffect, useMemo, useRef, useCallback } = React;

// Constants
const AUTO_SAVE_DELAY = 2000;
const LOCATION_PREVIEW_LENGTH = 50;
const MAX_HISTORY_SIZE = 50;
const DEBOUNCE_DELAY = 300;

// Debounce hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const handler = setTimeout(() => setDebouncedValue(value), delay);
    return () => clearTimeout(handler);
  }, [value, delay]);
  return debouncedValue;
}

// Create empty item helper
function createEmptyItem() {
  return {
    id: "",
    admin: "",
    proof: "",
    galley: "",
    isHeading: false,
    _adminEditor: "",
    _proofEditor: "",
    _galleyEditor: "",
    _adminImplemented: false,
    _proofImplemented: false,
    _galleyImplemented: false
  };
}

// Chevron icons
function ChevronDown() {
  return (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  );
}

function ChevronUp() {
  return (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  );
}

// Save status indicator
function SaveIndicator({ status }) {
  if (status === "saving") {
    return (
      <span className="save-indicator text-xs text-[#C99700] opacity-100" style={{ display: 'inline-block', width: '16px', height: '16px' }}>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
          <polyline points="17 21 17 13 7 13 7 21"></polyline>
          <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
      </span>
    );
  }
  if (status === "saved") {
    return <span className="save-indicator text-xs text-[#4ADE80] opacity-100">âœ“</span>;
  }
  if (status === "error") {
    return <span className="save-indicator text-xs text-red-300 opacity-100">âš </span>;
  }
  return <span className="save-indicator text-xs opacity-0"></span>;
}

// Rich text cell component
function RichTextCell({ value, onChange, placeholder, column, commentId, itemIndex, addRowAfter }) {
  const editorRef = useRef(null);
  const isUpdatingRef = useRef(false);

  useEffect(() => {
    if (editorRef.current && !editorRef.current.innerHTML) {
      editorRef.current.innerHTML = value || "";
    }
  }, [value]);

  useEffect(() => {
    if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
      if (editorRef.current.innerHTML !== value && value !== undefined) {
        editorRef.current.innerHTML = value || "";
      }
    }
  }, [value]);

  const handleInput = useCallback((e) => {
    isUpdatingRef.current = true;
    let rawHtml = e.target.innerHTML;
    
    // Convert any nbsp to degree symbols (catches browser insertions during editing)
    rawHtml = rawHtml.replace(/\u00A0/g, 'Â°');
    rawHtml = rawHtml.replace(/&nbsp;/gi, 'Â°');
    
    if (rawHtml !== e.target.innerHTML) {
      // Save cursor position
      const sel = window.getSelection();
      const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
      const offset = range ? range.startOffset : 0;
      const container = range ? range.startContainer : null;
      
      e.target.innerHTML = rawHtml;
      
      // Restore cursor position
      if (container && e.target.contains(container)) {
        try {
          const newRange = document.createRange();
          newRange.setStart(container, Math.min(offset, container.length || 0));
          newRange.collapse(true);
          sel.removeAllRanges();
          sel.addRange(newRange);
        } catch (err) {
          // If cursor restoration fails, continue
        }
      }
    }
    
    onChange(rawHtml);
    isUpdatingRef.current = false;
  }, [onChange]);

  const handlePaste = useCallback((e) => {
    e.preventDefault();
    const html = e.clipboardData.getData("text/html");

    if (html) {
      const temp = document.createElement("div");
      temp.innerHTML = html;

      const processNode = (node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          // Convert nbsp to degree symbols in text content
          const text = node.textContent.replace(/\u00A0/g, 'Â°');
          return document.createTextNode(text);
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName.toLowerCase();
          const style = node.style;
          const styleAttr = node.getAttribute("style") || "";
          
          const isBold = tagName === "b" || tagName === "strong" ||
            style.fontWeight === "bold" || style.fontWeight === "700" ||
            styleAttr.includes("font-weight: bold") || styleAttr.includes("font-weight:bold");
          const isItalic = tagName === "i" || tagName === "em" ||
            style.fontStyle === "italic" ||
            styleAttr.includes("font-style: italic") || styleAttr.includes("font-style:italic");

          const children = Array.from(node.childNodes).map(processNode);

          // Build the element hierarchy - italic, then bold outermost
          let resultElement = null;
          
          if (isItalic) {
            const em = document.createElement("em");
            children.forEach((child) => em.appendChild(child));
            resultElement = em;
          }
          
          if (isBold) {
            const strong = document.createElement("strong");
            if (resultElement) {
              strong.appendChild(resultElement);
            } else {
              children.forEach((child) => strong.appendChild(child));
            }
            resultElement = strong;
          }
          
          if (resultElement) {
            return resultElement;
          } else {
            const fragment = document.createDocumentFragment();
            children.forEach((child) => fragment.appendChild(child));
            return fragment;
          }
        }

        return document.createTextNode("");
      };

      const processed = document.createDocumentFragment();
      Array.from(temp.childNodes).forEach((node) => {
        processed.appendChild(processNode(node));
      });

      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        range.deleteContents();
        range.insertNode(processed);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
      }
      
      // Trigger input event to save changes
      if (editorRef.current) {
        editorRef.current.dispatchEvent(new Event('input', { bubbles: true }));
      }
    } else {
      const text = e.clipboardData.getData("text/plain");
      // Convert nbsp to degree symbols in plain text too
      const convertedText = text.replace(/\u00A0/g, 'Â°');
      document.execCommand("insertText", false, convertedText);
    }
  }, []);

  const handleCopy = useCallback((e) => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = document.createElement("div");
      container.appendChild(range.cloneContents());

      // Remove background styling but keep other formatting
      container.querySelectorAll('[style*="background"]').forEach((el) => {
        el.style.backgroundColor = "";
        el.style.background = "";
      });
      
      let html = container.innerHTML;
      
      // Step 1: Remove ALL nbsp (these are all browser-inserted since we never store them)
      html = html.replace(/\u00A0/g, '');
      html = html.replace(/&nbsp;/gi, '');
      
      // Step 2: Convert degree symbols back to nbsp (these are user-intentional)
      html = html.replace(/Â°/g, '\u00A0');
      
      // Wrap content with Georgia 12pt font for consistent pasting
      const wrappedHtml = '<span style="font-family:Georgia,serif;font-size:12pt;">' + html + '</span>';

      // For plain text, also convert degree symbols to nbsp
      let plainText = container.textContent.replace(/Â°/g, '\u00A0');
      
      e.clipboardData.setData("text/plain", plainText);
      e.clipboardData.setData("text/html", wrappedHtml);
      e.preventDefault();
    }
  }, []);

  const handleKeyDown = useCallback((e) => {
    // Intercept nbsp key combinations and insert degree symbol instead
    // Mac: Option+Space, Windows: Ctrl+Shift+Space
    if (e.key === ' ' && (e.altKey || (e.ctrlKey && e.shiftKey))) {
      e.preventDefault();
      document.execCommand("insertText", false, "Â°");
      return;
    }

    if ((e.metaKey || e.ctrlKey) && e.key === "b") {
      e.preventDefault();
      document.execCommand("bold", false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === "i") {
      e.preventDefault();
      document.execCommand("italic", false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === "u") {
      e.preventDefault();
      document.execCommand("underline", false, null);
      return;
    }

    if (e.shiftKey && e.key === "Enter") {
      e.preventDefault();
      // Add a new row and focus on it
      if (addRowAfter && commentId && itemIndex !== undefined) {
        addRowAfter(commentId, itemIndex);
        // Focus on the new row after it's created
        setTimeout(() => {
          const allCells = Array.from(document.querySelectorAll('[data-cell-column="' + column + '"]'));
          const currentIndex = allCells.indexOf(editorRef.current);
          const nextCell = allCells[currentIndex + 1];
          if (nextCell) {
            nextCell.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            if (nextCell.childNodes.length > 0) {
              range.setStart(nextCell, 0);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        }, 50);
      }
      return;
    }
    if (e.key === "Tab") {
      e.preventDefault();
      const allCells = Array.from(document.querySelectorAll('[data-cell-column="' + column + '"]'));
      const currentIndex = allCells.indexOf(editorRef.current);
      const nextIndex = e.shiftKey ? currentIndex - 1 : currentIndex + 1;

      if (nextIndex >= 0 && nextIndex < allCells.length) {
        const nextCell = allCells[nextIndex];
        nextCell.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        if (nextCell.childNodes.length > 0) {
          range.selectNodeContents(nextCell);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    }
  }, [column, addRowAfter, commentId, itemIndex]);

  return (
    <div className="relative w-full" style={{ paddingRight: "20px" }}>
      <div
        ref={editorRef}
        contentEditable
        onInput={handleInput}
        onPaste={handlePaste}
        onCopy={handleCopy}
        onKeyDown={handleKeyDown}
        data-cell-column={column}
        className="w-full min-h-[1.4rem] bg-transparent focus:bg-gray-100 focus:ring-1 focus:ring-gray-400 rounded px-1 py-0.5 cursor-text leading-tight"
        style={{
          wordWrap: "break-word",
          whiteSpace: "pre-wrap",
          fontFamily: "Georgia, serif",
          fontSize: "12pt"
        }}
        suppressContentEditableWarning
      />
      {!value && (
        <div className="absolute top-0.5 left-1 text-gray-400 pointer-events-none select-none italic" style={{ fontFamily: "Georgia, serif", fontSize: "12pt" }}>
          {placeholder}
        </div>
      )}
    </div>
  );
}

const MemoizedRichTextCell = React.memo(RichTextCell);

// Main component
function CommentViewer() {
  const [expandedComments, setExpandedComments] = useState(new Set());
  const [collapsedColumns, setCollapsedColumns] = useState(new Set());
  const [comments, setComments] = useState([]);
  const [officeReady, setOfficeReady] = useState(false);
  const [loading, setLoading] = useState(true);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCommentId, setNewCommentId] = useState("");
  const [newCommentLocation, setNewCommentLocation] = useState("");
  const [saveStatus, setSaveStatus] = useState("idle");
  const saveTimeoutRef = useRef(null);
  const commentIdInputRef = useRef(null);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [currentUsername, setCurrentUsername] = useState(() => {
    try {
      return localStorage.getItem("lawReviewUsername") || null;
    } catch (e) {
      return null;
    }
  });
  const [showUsernameDialog, setShowUsernameDialog] = useState(false);
  const [tempUsername, setTempUsername] = useState("");
  const pendingEditRef = useRef(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [deleteConfirm, setDeleteConfirm] = useState(null);

  const debouncedSearchQuery = useDebounce(searchQuery, DEBOUNCE_DELAY);

  // Persist username
  useEffect(() => {
    if (currentUsername) {
      try {
        localStorage.setItem("lawReviewUsername", currentUsername);
      } catch (e) {
        console.error("Could not save username to localStorage");
      }
    }
  }, [currentUsername]);

  const applyFormat = useCallback((command) => {
    // Simple execCommand - nbsp cleanup happens in handleInput
    document.execCommand(command, false, null);
  }, []);

  const toggleHighlight = useCallback(() => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const parent = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;

      if (parent && parent.style.backgroundColor === "yellow") {
        document.execCommand("hiliteColor", false, "transparent");
      } else {
        document.execCommand("hiliteColor", false, "yellow");
      }
    }
  }, []);

  const toggleRed = useCallback(() => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0 && !selection.isCollapsed) {
      const range = selection.getRangeAt(0);
      
      // Check the actual selected elements in the DOM for red color
      let hasRed = false;
      const container = range.commonAncestorContainer;
      
      if (container.nodeType === Node.TEXT_NODE) {
        const parent = container.parentElement;
        if (parent) {
          const computedColor = window.getComputedStyle(parent).color;
          hasRed = computedColor === "rgb(255, 0, 0)" || parent.style.color === "red";
        }
      } else if (container.nodeType === Node.ELEMENT_NODE) {
        const computedColor = window.getComputedStyle(container).color;
        hasRed = computedColor === "rgb(255, 0, 0)" || container.style.color === "red";
      }
      
      // Also check if selection spans multiple elements with red
      const rangeContainer = document.createElement("div");
      rangeContainer.appendChild(range.cloneContents());
      if (!hasRed) {
        hasRed = rangeContainer.querySelector('[style*="color: red"]') !== null ||
                 rangeContainer.querySelector('[style*="color: rgb(255, 0, 0)"]') !== null ||
                 rangeContainer.querySelector('font[color="red"]') !== null;
      }

      if (hasRed) {
        document.execCommand("foreColor", false, "black");
      } else {
        document.execCommand("foreColor", false, "red");
      }
    }
  }, []);



  const toggleCellImplemented = useCallback((commentId, itemIndex, column) => {
    setComments((prevComments) => prevComments.map((comment) => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        const item = newItems[itemIndex];
        const implKey = "_" + column + "Implemented";
        newItems[itemIndex] = { ...item, [implKey]: !item[implKey] };
        return { ...comment, items: newItems };
      }
      return comment;
    }));
  }, []);

  const saveToHistory = useCallback((newComments) => {
    setHistory((prevHistory) => {
      const newHistory = prevHistory.slice(0, historyIndex + 1);
      newHistory.push(JSON.parse(JSON.stringify(newComments)));
      if (newHistory.length > MAX_HISTORY_SIZE) {
        newHistory.shift();
      }
      return newHistory;
    });
    setHistoryIndex((prev) => Math.min(prev + 1, MAX_HISTORY_SIZE - 1));
  }, [historyIndex]);

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      const previousState = history[historyIndex - 1];
      setComments(JSON.parse(JSON.stringify(previousState)));
      setHistoryIndex(historyIndex - 1);
    }
  }, [history, historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const nextState = history[historyIndex + 1];
      setComments(JSON.parse(JSON.stringify(nextState)));
      setHistoryIndex(historyIndex + 1);
    }
  }, [history, historyIndex]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleGlobalKeyDown = (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "z") {
        if (e.shiftKey) {
          e.preventDefault();
          redo();
        } else {
          const activeEl = document.activeElement;
          if (!activeEl || activeEl.contentEditable !== "true") {
            e.preventDefault();
            undo();
          }
        }
      }
    };

    window.addEventListener("keydown", handleGlobalKeyDown);
    return () => window.removeEventListener("keydown", handleGlobalKeyDown);
  }, [undo, redo]);

  // Office ready
  useEffect(() => {
    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        setOfficeReady(true);
        loadCommentsFromWord();
      }
    });
  }, []);

  // Auto-save
  useEffect(() => {
    if (!officeReady || comments.length === 0) return;

    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    setSaveStatus("idle");
    saveTimeoutRef.current = setTimeout(() => {
      saveCommentsToWordSilent();
    }, AUTO_SAVE_DELAY);

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [comments, officeReady]);

  async function loadCommentsFromWord() {
    setLoading(true);
    try {
      await Word.run(async (context) => {
        const wordComments = context.document.body.getComments();
        wordComments.load("items");
        await context.sync();

        const commentData = [];
        for (let i = 0; i < wordComments.items.length; i++) {
          const comment = wordComments.items[i];
          comment.load("content");
          const range = comment.getRange();
          range.load("start");
          await context.sync();

          const content = comment.content;
          let commentId;
          let tableData;

          if (content.includes("|||")) {
            const parts = content.split("|||");
            commentId = parts[0];
            try {
              tableData = JSON.parse(parts[1]);
            } catch (e) {
              console.error("Error parsing comment data:", e);
              tableData = { items: [createEmptyItem()] };
            }
          } else {
            commentId = content;
            tableData = { items: [createEmptyItem()] };
          }

          commentData.push({
            id: commentId,
            position: range.start,
            location: "Position " + range.start,
            timestamp: new Date().toISOString().split("T")[0],
            items: tableData.items
          });
        }

        commentData.sort((a, b) => a.position - b.position);
        setComments(commentData);

        if (commentData.length > 0) {
          setHistory([JSON.parse(JSON.stringify(commentData))]);
          setHistoryIndex(0);
          setExpandedComments(new Set([commentData[0].id]));
        }
      });
    } catch (error) {
      console.error("Error loading comments:", error);
      alert("Error loading comments:  " + error.message);
    } finally {
      setLoading(false);
    }
  }

  async function saveCommentsToWordSilent() {
    if (!officeReady) return;

    setSaveStatus("saving");
    try {
      await Word.run(async (context) => {
        const wordComments = context.document.body.getComments();
        wordComments.load("items");
        await context.sync();

        for (let i = 0; i < wordComments.items.length; i++) {
          const wordComment = wordComments.items[i];
          wordComment.load("content");
          await context.sync();

          const currentContent = wordComment.content;
          const commentId = currentContent.includes("|||") ? currentContent.split("|||")[0] : currentContent;
          const ourComment = comments.find((c) => c.id === commentId);

          if (ourComment) {
            const newContent = ourComment.id + "|||" + JSON.stringify({ items: ourComment.items });
            if (wordComment.content !== newContent) {
              wordComment.content = newContent;
            }
          }
        }

        await context.sync();
        setSaveStatus("saved");
        setTimeout(() => setSaveStatus("idle"), 2000);
      });
    } catch (error) {
      console.error("Error auto-saving:", error);
      setSaveStatus("error");
      setTimeout(() => setSaveStatus("idle"), 3000);
    }
  }

  async function createNewCommentFromSelection() {
    if (!officeReady) {
      alert("Please wait for Office to finish loading");
      return;
    }

    try {
      await Word.run(async (context) => {
        const range = context.document.getSelection();
        range.load("text");
        await context.sync();

        if (range.text.length === 0) {
          alert("Please select some text first!");
          return;
        }

        let locationText = range.text.substring(0, LOCATION_PREVIEW_LENGTH);
        if (range.text.length > LOCATION_PREVIEW_LENGTH) {
          locationText += "...";
        }

        setNewCommentLocation('Text: "' + locationText + '"');
        setShowCreateDialog(true);
      });
    } catch (error) {
      console.error("Error creating comment:", error);
      alert("Error creating comment: " + error.message);
    }
  }

  async function finalizeCreateComment() {
    if (!newCommentId.trim()) {
      alert("Please enter a comment ID!");
      return;
    }
    if (comments.some((c) => c.id === newCommentId)) {
      alert("A comment with this ID already exists!");
      return;
    }

    try {
      await Word.run(async (context) => {
        const range = context.document.getSelection();
        range.insertComment(newCommentId);
        await context.sync();

        const timestamp = new Date();
        const newComment = {
          id: newCommentId,
          location: newCommentLocation,
          timestamp: timestamp.toISOString().split("T")[0] + " " + timestamp.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" }),
          items: [createEmptyItem()]
        };

        const updatedComments = [...comments, newComment];
        setComments(updatedComments);
        saveToHistory(updatedComments);

        setExpandedComments((prev) => new Set([...prev, newCommentId]));

        setShowCreateDialog(false);
        setNewCommentId("");
        setNewCommentLocation("");

        alert("Comment created successfully!");
      });
    } catch (error) {
      console.error("Error finalizing comment:", error);
      alert("Error creating comment: " + error.message);
    }
  }

  async function jumpToComment(commentId) {
    try {
      await Word.run(async (context) => {
        const wordComments = context.document.body.getComments();
        wordComments.load("items");
        await context.sync();

        let found = false;
        for (let i = 0; i < wordComments.items.length; i++) {
          const comment = wordComments.items[i];
          comment.load("content");
          await context.sync();

          const content = comment.content;
          const actualCommentId = content.includes("|||") ? content.split("|||")[0] : content;

          if (actualCommentId === commentId) {
            const range = comment.getRange();
            range.select();
            found = true;
            break;
          }
        }

        if (!found) {
          alert("Could not find this comment in the document.");
        }
      });
    } catch (error) {
      console.error("Error jumping to comment:", error);
      alert("Error navigating to comment: " + error.message);
    }
  }

  const filteredComments = useMemo(() => {
    if (!debouncedSearchQuery.trim()) return comments;

    const query = debouncedSearchQuery.toLowerCase();
    return comments.filter((comment) => {
      if (comment.id.toLowerCase().includes(query)) return true;
      if (comment.location.toLowerCase().includes(query)) return true;

      return comment.items.some((item) => {
        const stripHtml = (html) => {
          const temp = document.createElement("div");
          temp.innerHTML = html || "";
          return temp.textContent || temp.innerText || "";
        };

        return (
          (item.id && item.id.toLowerCase().includes(query)) ||
          stripHtml(item.admin).toLowerCase().includes(query) ||
          stripHtml(item.proof).toLowerCase().includes(query) ||
          stripHtml(item.galley).toLowerCase().includes(query)
        );
      });
    });
  }, [comments, debouncedSearchQuery]);

  const toggleExpand = useCallback((commentId) => {
    setExpandedComments((prev) => {
      const newExpanded = new Set(prev);
      if (newExpanded.has(commentId)) {
        newExpanded.delete(commentId);
      } else {
        newExpanded.add(commentId);
      }
      return newExpanded;
    });
  }, []);

  const expandAll = useCallback(() => {
    setExpandedComments(new Set(comments.map((c) => c.id)));
  }, [comments]);

  const collapseAll = useCallback(() => {
    setExpandedComments(new Set());
  }, []);

  const toggleColumn = useCallback((columnName) => {
    setCollapsedColumns((prev) => {
      const newCollapsed = new Set(prev);
      if (newCollapsed.has(columnName)) {
        newCollapsed.delete(columnName);
      } else {
        newCollapsed.add(columnName);
      }
      return newCollapsed;
    });
  }, []);

  const addRowAfter = useCallback((commentId, afterIndex) => {
    setComments((prevComments) => {
      const newComments = prevComments.map((comment) => {
        if (comment.id === commentId) {
          const newItems = [...comment.items];
          newItems.splice(afterIndex + 1, 0, createEmptyItem());
          return { ...comment, items: newItems };
        }
        return comment;
      });
      saveToHistory(newComments);
      return newComments;
    });
  }, [saveToHistory]);

  const toggleHeading = useCallback((commentId, itemIndex) => {
    setComments((prevComments) => {
      const newComments = prevComments.map((comment) => {
        if (comment.id === commentId) {
          const newItems = [...comment.items];
          newItems[itemIndex] = {...newItems[itemIndex], isHeading: !newItems[itemIndex].isHeading};
          return { ...comment, items: newItems };
        }
        return comment;
      });
      saveToHistory(newComments);
      return newComments;
    });
  }, [saveToHistory]);

  const updateCell = useCallback((commentId, itemIndex, column, value) => {
    if (!currentUsername && column !== "id" && column !== "isHeading" && !column.startsWith("_") && value && value.trim()) {
      pendingEditRef.current = { commentId: commentId, itemIndex: itemIndex, column: column, value: value };
      setShowUsernameDialog(true);
      return;
    }

    setComments((prevComments) => prevComments.map((comment) => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        const updatedItem = {...newItems[itemIndex], [column]: value};

        if (currentUsername && column !== "id" && column !== "isHeading" && !column.startsWith("_")) {
          const editorKey = "_" + column + "Editor";
          updatedItem[editorKey] = currentUsername;
        }

        newItems[itemIndex] = updatedItem;
        return {...comment, items: newItems};
      }
      return comment;
    }));
  }, [currentUsername]);

  const confirmUsername = useCallback(() => {
    if (tempUsername.trim()) {
      const username = tempUsername.trim();
      setCurrentUsername(username);
      setShowUsernameDialog(false);

      if (pendingEditRef.current) {
        const pending = pendingEditRef.current;
        setComments((prevComments) => prevComments.map((comment) => {
          if (comment.id === pending.commentId) {
            const newItems = [...comment.items];
            const updatedItem = { ...newItems[pending.itemIndex], [pending.column]: pending.value };
            const editorKey = "_" + pending.column + "Editor";
            updatedItem[editorKey] = username;
            newItems[pending.itemIndex] = updatedItem;
            return { ...comment, items: newItems };
          }
          return comment;
        }));
        pendingEditRef.current = null;
      }
      setTempUsername("");
    }
  }, [tempUsername]);

  const deleteRow = useCallback((commentId, itemIndex) => {
    setComments((prevComments) => {
      const newComments = prevComments.map((comment) => {
        if (comment.id === commentId) {
          if (comment.items.length <= 1) {
            alert("Cannot delete the last row. Delete the comment from Word instead.");
            return comment;
          }
          const newItems = comment.items.filter((_, idx) => idx !== itemIndex);
          return { ...comment, items: newItems };
        }
        return comment;
      });
      saveToHistory(newComments);
      return newComments;
    });
    setDeleteConfirm(null);
  }, [saveToHistory]);

  const handleDialogKeyDown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      finalizeCreateComment();
    } else if (e.key === "Escape") {
      setShowCreateDialog(false);
      setNewCommentId("");
      setNewCommentLocation("");
    }
  };

  useEffect(() => {
    if (showCreateDialog && commentIdInputRef.current) {
      commentIdInputRef.current.focus();
    }
  }, [showCreateDialog]);

  const exportComments = useCallback(() => {
    const dataStr = JSON.stringify(comments, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "law-review-comments-" + new Date().toISOString().split("T")[0] + ".json";
    link.click();
    URL.revokeObjectURL(url);
  }, [comments]);

  // Column definitions
  const columns = [
    { key: "admin", label: "Admin" },
    { key: "proof", label: "Proof" },
    { key: "galley", label: "Galley" }
  ];

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      {/* Header */}
      <div className="bg-[#0C2340] border-b border-[#1E3A5F] px-3 py-1.5">
        <div className="flex items-center justify-between gap-2 mb-1.5">
          <div className="flex items-center gap-2">
            <h1 className="text-sm font-semibold text-white">Law Review Comments</h1>
            <SaveIndicator status={saveStatus} />
          </div>
          <div className="flex gap-1">
            <button
              onClick={createNewCommentFromSelection}
              className="bg-[#C99700] hover:bg-[#B8860B] text-white px-2 py-0.5 rounded text-xs font-medium transition-colors cursor-pointer"
            >
              + New
            </button>
            <button
              onClick={loadCommentsFromWord}
              className="bg-[#1E3A5F] hover:bg-[#2D4A6F] text-white px-2 py-0.5 rounded text-xs font-medium transition-colors cursor-pointer"
            >
              â†» Refresh
            </button>
            <button
              onClick={undo}
              disabled={historyIndex <= 0}
              className={(historyIndex <= 0 ? "bg-[#4A5568] cursor-not-allowed" : "bg-[#1E3A5F] hover:bg-[#2D4A6F] cursor-pointer") + " text-white px-2 py-0.5 rounded text-xs font-medium transition-colors"}
              title="Undo (Ctrl+Z)"
            >
              âŽŒ
            </button>
            <button
              onClick={redo}
              disabled={historyIndex >= history.length - 1}
              className={(historyIndex >= history.length - 1 ? "bg-[#4A5568] cursor-not-allowed" : "bg-[#1E3A5F] hover:bg-[#2D4A6F] cursor-pointer") + " text-white px-2 py-0.5 rounded text-xs font-medium transition-colors"}
              title="Redo (Ctrl+Shift+Z)"
            >
              â†·
            </button>
            <button
              onClick={exportComments}
              className="bg-[#1E3A5F] hover:bg-[#2D4A6F] text-white px-2 py-0.5 rounded text-xs font-medium transition-colors cursor-pointer"
              title="Export to JSON"
            >
              â†“
            </button>
          </div>
        </div>

        {/* Formatting toolbar */}
        <div className="flex gap-1 flex-wrap">
          <button
            onClick={() => applyFormat("bold")}
            className="px-2 py-0.5 bg-[#334155] hover:bg-[#1E293B] border border-[#475569] rounded font-bold text-white text-xs transition-colors"
            title="Bold (Ctrl+B)"
          >
            B
          </button>
          <button
            onClick={() => applyFormat("italic")}
            className="px-2 py-0.5 bg-[#334155] hover:bg-[#1E293B] border border-[#475569] rounded italic text-white text-xs transition-colors"
            title="Italic (Ctrl+I)"
          >
            I
          </button>
          <button
            onClick={toggleHighlight}
            className="px-2 py-0.5 bg-[#C99700] hover:bg-[#B8860B] border border-[#B8860B] rounded text-white text-xs font-medium transition-colors"
            title="Toggle Highlight"
          >
            H
          </button>
          <button
            onClick={toggleRed}
            className="px-2 py-0.5 bg-red-500 hover:bg-red-600 border border-red-600 rounded text-white text-xs font-medium transition-colors"
            title="Toggle Red Text"
          >
            R
          </button>

          <button
            onClick={() => applyFormat("removeFormat")}
            className="px-2 py-0.5 bg-[#334155] hover:bg-[#1E293B] border border-[#475569] rounded text-red-400 text-xs transition-colors"
            title="Clear Formatting"
          >
            âœ•
          </button>
          <div className="border-l border-gray-500 mx-1"></div>
          <button
            onClick={expandAll}
            className="px-2 py-0.5 bg-[#334155] hover:bg-[#1E293B] border border-[#475569] rounded text-white text-xs transition-colors"
            title="Expand All"
          >
            âŠž
          </button>
          <button
            onClick={collapseAll}
            className="px-2 py-0.5 bg-[#334155] hover:bg-[#1E293B] border border-[#475569] rounded text-white text-xs transition-colors"
            title="Collapse All"
          >
            âŠŸ
          </button>
        </div>

        {/* Search bar */}
        <div className="mt-1.5 flex gap-2 items-center">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search comments..."
            className="flex-1 px-2 py-1 text-xs border border-gray-500 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-gray-400"
          />
          {searchQuery && (
            <button
              onClick={() => setSearchQuery("")}
              className="text-gray-400 hover:text-white text-xs"
            >
              âœ•
            </button>
          )}
          {currentUsername && (
            <div className="text-xs text-gray-300 flex items-center gap-1">
              <span>ðŸ‘¤ {currentUsername}</span>
              <button
                onClick={() => setCurrentUsername(null)}
                className="text-gray-400 hover:text-white"
                title="Change user"
              >
                âœŽ
              </button>
            </div>
          )}
        </div>
      </div>

      {/* Username Dialog */}
      {showUsernameDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50 fade-in">
          <div className="bg-white rounded-lg p-6 max-w-sm w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Enter Your Name</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Your name will appear on cells you edit
              </label>
              <input
                type="text"
                value={tempUsername}
                onChange={(e) => setTempUsername(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    e.preventDefault();
                    confirmUsername();
                  } else if (e.key === "Escape") {
                    setShowUsernameDialog(false);
                    pendingEditRef.current = null;
                    setTempUsername("");
                  }
                }}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
                placeholder="Your name"
                autoFocus
              />
            </div>
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => {
                  setShowUsernameDialog(false);
                  pendingEditRef.current = null;
                  setTempUsername("");
                }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={confirmUsername}
                className="px-4 py-2 bg-[#C99700] text-white rounded hover:bg-[#B8860B] text-sm font-medium transition-colors"
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Create Comment Dialog */}
      {showCreateDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50 fade-in">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Create New Comment</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Comment ID (e.g., "125A")
              </label>
              <input
                ref={commentIdInputRef}
                type="text"
                value={newCommentId}
                onChange={(e) => setNewCommentId(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
                placeholder="125A"
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">Location</label>
              <input
                type="text"
                value={newCommentLocation}
                onChange={(e) => setNewCommentLocation(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
              />
              <p className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                ðŸ’¡ A Word comment will appear in the margin. To delete later, just delete the Word comment and click Refresh.
              </p>
            </div>
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => {
                  setShowCreateDialog(false);
                  setNewCommentId("");
                  setNewCommentLocation("");
                }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={finalizeCreateComment}
                className="px-4 py-2 bg-[#C99700] text-white rounded hover:bg-[#B8860B] text-sm font-medium transition-colors"
              >
                Create Comment
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Delete Confirmation Dialog */}
      {deleteConfirm && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50 fade-in">
          <div className="bg-white rounded-lg p-6 max-w-sm w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Delete Row?</h2>
            <p className="text-sm text-gray-600 mb-4">Are you sure you want to delete this row?  This action can be undone.</p>
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => setDeleteConfirm(null)}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={() => deleteRow(deleteConfirm.commentId, deleteConfirm.itemIndex)}
                className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm font-medium transition-colors"
              >
                Delete
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Main Content */}
      <div className="flex-1 overflow-y-auto p-2">
        {loading ? (
          <div className="text-center text-gray-500 mt-8">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-2 border-gray-300 border-t-gray-600 mb-2"></div>
            <p className="text-sm">Loading comments...</p>
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8 bg-white p-6 rounded border border-gray-200 max-w-sm mx-auto">
            <p className="text-base mb-2">ðŸ“‹ No comments yet</p>
            <p className="text-xs mb-1">Select some text and click "New Comment" to get started.</p>
            <p className="text-xs mt-3 text-gray-400">ðŸ’¡ Tip: Delete comments by right-clicking the Word comment in the margin, then click Refresh here.</p>
          </div>
        ) : filteredComments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">
            <p>No comments match "{debouncedSearchQuery}"</p>
            <button
              onClick={() => setSearchQuery("")}
              className="mt-2 text-sky-500 hover:text-sky-600 text-sm"
            >
              Clear search
            </button>
          </div>
        ) : (
          filteredComments.map((comment) => (
            <div
              key={comment.id}
              id={"comment-" + comment.id}
              className={"mb-2 bg-white rounded border border-gray-200 shadow-sm" + (expandedComments.has(comment.id) ? " border-l-4 border-[#C99700]" : "")}
            >
              {/* Comment Header */}
              <div className="px-1.5 py-0.5 bg-gray-50 border-b border-gray-200 flex items-center justify-between gap-1.5">
                <div
                  className="flex items-center gap-1.5 flex-1 cursor-pointer hover:bg-gray-100 px-1 py-0.5 rounded transition-colors"
                  onClick={() => toggleExpand(comment.id)}
                >
                  {expandedComments.has(comment.id) ? <ChevronUp /> : <ChevronDown />}
                  <div className="text-xs">
                    <span
                      className="font-semibold text-gray-700 cursor-pointer hover:underline hover:text-[#C99700]"
                      onClick={(e) => {
                        e.stopPropagation();
                        jumpToComment(comment.id);
                      }}
                    >
                      {comment.id}
                    </span>
                    <span className="mx-1 text-gray-400">({comment.items.length})</span>
                    <span className="mx-1 text-gray-400">â€¢</span>
                    <span className="text-gray-600">{comment.location}</span>
                  </div>
                </div>
              </div>

              {/* Comment Table */}
              {expandedComments.has(comment.id) && (
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse text-xs">
                    <thead className="bg-gray-100 border-b border-gray-300">
                      <tr>
                        <th className="px-1.5 py-0.5 text-left font-semibold text-gray-700 border-r border-gray-200" style={{ minWidth: "40px", width: "40px" }}>#</th>
                        {columns.map((col) => (
                          !collapsedColumns.has(col.key) ? (
                            <th
                              key={col.key}
                              className="px-1.5 py-0.5 text-left font-semibold text-gray-700 border-r border-gray-200 cursor-pointer hover:bg-gray-200 transition-colors"
                              style={{ minWidth: "250px" }}
                              onClick={(e) => {
                                e.stopPropagation();
                                toggleColumn(col.key);
                              }}
                            >
                              <div className="flex items-center justify-between">
                                <div>
                                  <div>{col.label}</div>
                                  {(() => {
                                    const editorKey = "_" + col.key + "Editor";
                                    const editors = comment.items.map((item) => item[editorKey]).filter(Boolean);
                                    const lastEditor = editors[editors.length - 1];
                                    return lastEditor ? (
                                      <div className="text-xs font-normal text-gray-500 italic">{lastEditor}</div>
                                    ) : null;
                                  })()}
                                </div>
                                <ChevronUp />
                              </div>
                            </th>
                          ) : null
                        ))}
                        {collapsedColumns.size > 0 && (
                          <th className="px-1 py-1 text-center font-semibold text-gray-500 border-r border-gray-200">
                            <div className="flex flex-col gap-0.5">
                              {Array.from(collapsedColumns).map((col) => (
                                <button
                                  key={col}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleColumn(col);
                                  }}
                                  className="px-1.5 py-0.5 bg-gray-200 hover:bg-gray-300 rounded text-xs flex items-center gap-1 transition-colors"
                                >
                                  <ChevronDown /> {col.charAt(0).toUpperCase() + col.slice(1)}
                                </button>
                              ))}
                            </div>
                          </th>
                        )}
                        <th className="px-1 py-1 w-8"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {comment.items.map((item, idx) => {
                        const rowBgClass = item.isHeading ? "bg-[#FEF9C3]" : (idx % 2 === 0 ? "bg-white" : "bg-gray-50");
                        return (
                        <tr key={idx} className={`group ${rowBgClass} transition-colors`}>
                          <td className="px-1 py-0 font-semibold text-gray-700 border-r border-gray-200 align-top" style={{ minWidth: "40px", width: "40px" }}>
                            <input
                              type="text"
                              value={item.id}
                              onChange={(e) => updateCell(comment.id, idx, "id", e.target.value)}
                              className={"w-full bg-transparent border-none focus:outline-none focus:ring-1 focus:ring-gray-500 rounded px-1 py-1 text-xs" + (item.isHeading ? " font-bold" : "")}
                              placeholder="#"
                            />
                          </td>
                          {columns.map((col) => (
                            !collapsedColumns.has(col.key) ? (
                              <td
                                key={col.key}
                                className={"px-1 py-0 text-gray-800 border-r border-gray-200 align-top relative" + (item["_" + col.key + "Implemented"] ? " bg-[#DCFCE7]" : "")}
                              >
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleCellImplemented(comment.id, idx, col.key);
                                  }}
                                  className={"absolute top-0 right-0 w-5 h-5 flex items-center justify-center rounded text-xs transition-colors" + (item["_" + col.key + "Implemented"] ? " bg-[#00843D] text-white" : " bg-gray-200 text-gray-500 hover:bg-gray-300")}
                                  style={{ zIndex: 20, cursor: "pointer" }}
                                  title={item["_" + col.key + "Implemented"] ? "Mark as not implemented" : "Mark as implemented"}
                                >
                                  âœ“
                                </button>
                                <div className={item.isHeading ? "font-semibold" : ""}>
                                  <MemoizedRichTextCell
                                    value={item[col.key]}
                                    onChange={(html) => updateCell(comment.id, idx, col.key, html)}
                                    placeholder="â€”"
                                    column={col.key}
                                    commentId={comment.id}
                                    itemIndex={idx}
                                    addRowAfter={addRowAfter}
                                  />
                                </div>
                              </td>
                            ) : null
                          ))}
                          {collapsedColumns.size > 0 && <td className="border-r border-gray-200"></td>}
                          <td className="px-1 py-0 align-top">
                            <div className="opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity flex flex-col gap-0 py-0.5">
                              <button
                                onClick={() => addRowAfter(comment.id, idx)}
                                className="w-5 h-4 flex items-center justify-center bg-gray-100 hover:bg-gray-200 rounded text-gray-600 text-xs transition-colors"
                                title="Add row below"
                              >
                                +
                              </button>
                              <button
                                onClick={() => toggleHeading(comment.id, idx)}
                                className={"w-5 h-4 flex items-center justify-center rounded text-xs transition-colors" + (item.isHeading ? " bg-[#C99700] text-white" : " bg-gray-100 hover:bg-gray-200 text-gray-600")}
                                title="Toggle heading"
                              >
                                H
                              </button>
                              <button
                                onClick={() => setDeleteConfirm({ commentId: comment.id, itemIndex: idx })}
                                className="w-5 h-4 flex items-center justify-center bg-gray-100 hover:bg-red-100 hover:text-red-600 rounded text-gray-600 text-xs transition-colors"
                                title="Delete row"
                              >
                                Ã—
                              </button>
                            </div>
                          </td>
                        </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          ))
        )}
      </div>

      {/* Footer */}
      <div className="bg-[#F8FAFC] border-t border-[#E2E8F0] px-3 py-1 text-xs text-gray-500 flex justify-between">
        <span>{comments.length} comment{comments.length !== 1 ? "s" : ""} â€¢ {comments.reduce((acc, c) => acc + c.items.length, 0)} total items</span>
        <span>v44</span>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<CommentViewer />);
</script>
</body>
</html>
