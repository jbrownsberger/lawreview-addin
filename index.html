<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Law Review Comment Viewer - v35</title>

<script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
body { 
  margin: 0; 
  padding: 0; 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
[contenteditable] { outline: none; }
[contenteditable]:focus { background-color: #fef3c7; }

/* Smooth animations */
.comment-card {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.comment-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
}

/* Button styles */
.btn-primary {
  transition: all 0.2s ease;
}
.btn-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}
.btn-primary:active {
  transform: translateY(0);
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
console.log("Law Review Add-in Version 35 - Enhanced UI!");

const { useState, useEffect, useMemo, useRef } = React;

// Rich text cell component
function RichTextCell({ value, onChange, placeholder, commentId, itemIndex, column }) {
  const editorRef = useRef(null);
  const isUpdatingRef = useRef(false);

  useEffect(() => {
    if (editorRef.current && !editorRef.current.innerHTML) {
      editorRef.current.innerHTML = value || '';
    }
  }, []);

  useEffect(() => {
    if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
      const currentHtml = editorRef.current.innerHTML;
      if (currentHtml !== value && value !== undefined) {
        editorRef.current.innerHTML = value || '';
      }
    }
  }, [value]);

  const handleInput = (e) => {
    isUpdatingRef.current = true;
    const newHtml = e.target.innerHTML;
    onChange(newHtml);
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  };

  const handleKeyDown = (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'b') {
      e.preventDefault();
      document.execCommand('bold', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'i') {
      e.preventDefault();
      document.execCommand('italic', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
      e.preventDefault();
      document.execCommand('underline', false, null);
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      const allCells = Array.from(document.querySelectorAll(`[data-cell-column="${column}"]`));
      const currentIndex = allCells.indexOf(editorRef.current);
      if (currentIndex >= 0 && currentIndex < allCells.length - 1) {
        const nextCell = allCells[currentIndex + 1];
        nextCell.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        if (nextCell.childNodes.length > 0) {
          range.selectNodeContents(nextCell);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    }
  };

  return (
    <div className="relative w-full">
      <div
        ref={editorRef}
        contentEditable
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        data-cell-column={column}
        className="w-full min-h-[2.5rem] bg-transparent focus:bg-yellow-50 focus:ring-2 focus:ring-amber-400 rounded-lg px-3 py-2 cursor-text text-sm transition-all"
        style={{ wordWrap: 'break-word', whiteSpace: 'pre-wrap' }}
        suppressContentEditableWarning
      />
      {!value && (
        <div className="absolute top-2 left-3 text-gray-400 pointer-events-none select-none text-sm italic">
          {placeholder}
        </div>
      )}
    </div>
  );
}

function CommentViewer() {
  const [expandedComments, setExpandedComments] = useState(new Set());
  const [collapsedColumns, setCollapsedColumns] = useState(new Set());
  const [comments, setComments] = useState([]);
  const [officeReady, setOfficeReady] = useState(false);
  const [loading, setLoading] = useState(true);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCommentId, setNewCommentId] = useState('');
  const [newCommentLocation, setNewCommentLocation] = useState('');
  const saveTimeoutRef = useRef(null);

  const applyFormat = (command) => {
    document.execCommand(command, false, null);
  };

  const applyHighlight = () => {
    document.execCommand('hiliteColor', false, 'yellow');
  };

  useEffect(() => {
    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        setOfficeReady(true);
        loadCommentsFromWord();
      }
    });
  }, []);

  useEffect(() => {
    if (!officeReady || comments.length === 0) return;
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveCommentsToWordSilent();
    }, 2000);
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [comments, officeReady]);

  async function loadCommentsFromWord() {
    setLoading(true);
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          const commentData = [];
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            const range = comment.getRange();
            range.load("start");
            await context.sync();

            const content = comment.content;
            let commentId, tableData;
            if (content.includes('|||')) {
              const parts = content.split('|||');
              commentId = parts[0];
              try {
                tableData = JSON.parse(parts[1]);
              } catch (e) {
                console.error("Error parsing comment data:", e);
                tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
              }
            } else {
              commentId = content;
              tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
            }

            commentData.push({
              id: commentId,
              position: range.start,
              location: `Position ${range.start}`,
              timestamp: new Date().toISOString().split('T')[0],
              items: tableData.items
            });
          }

          commentData.sort((a, b) => a.position - b.position);
          setComments(commentData);

          if (commentData.length > 0) {
            setExpandedComments(new Set([commentData[0].id]));
          }
        });
      } catch (error) {
        console.error("Error loading comments:", error);
        alert("Error loading comments: " + error.message);
      } finally {
        setLoading(false);
      }
    }, 100);
  }

  function save
