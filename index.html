<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Law Review Comment Viewer - v35</title>

<script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
body { 
  margin: 0; 
  padding: 0; 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}
[contenteditable] { outline: none; }
[contenteditable]:focus { background-color: #fefce8; }

/* Smooth transitions */
* {
  transition: background-color 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 10px;
}
::-webkit-scrollbar-track {
  background: #f1f1f1;
}
::-webkit-scrollbar-thumb {
  background: #667eea;
  border-radius: 5px;
}
::-webkit-scrollbar-thumb:hover {
  background: #764ba2;
}

/* Subtle animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.comment-card {
  animation: fadeIn 0.3s ease;
}

/* Glassmorphism effect */
.glass {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
console.log("Law Review Add-in Version 35 - Enhanced aesthetics + Enter to submit!");

const { useState, useEffect, useMemo, useRef } = React;

// Rich text cell component
function RichTextCell({ value, onChange, placeholder, commentId, itemIndex, column }) {
  const editorRef = useRef(null);
  const isUpdatingRef = useRef(false);

  useEffect(() => {
    if (editorRef.current && !editorRef.current.innerHTML) {
      editorRef.current.innerHTML = value || '';
    }
  }, []);

  useEffect(() => {
    if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
      const currentHtml = editorRef.current.innerHTML;
      if (currentHtml !== value && value !== undefined) {
        editorRef.current.innerHTML = value || '';
      }
    }
  }, [value]);

  const handleInput = (e) => {
    isUpdatingRef.current = true;
    const newHtml = e.target.innerHTML;
    onChange(newHtml);
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  };

  const handleKeyDown = (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'b') {
      e.preventDefault();
      document.execCommand('bold', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'i') {
      e.preventDefault();
      document.execCommand('italic', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
      e.preventDefault();
      document.execCommand('underline', false, null);
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      const allCells = Array.from(document.querySelectorAll(`[data-cell-column="${column}"]`));
      const currentIndex = allCells.indexOf(editorRef.current);
      if (currentIndex >= 0 && currentIndex < allCells.length - 1) {
        const nextCell = allCells[currentIndex + 1];
        nextCell.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        if (nextCell.childNodes.length > 0) {
          range.selectNodeContents(nextCell);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    }
  };

  return (
    <div className="relative w-full">
      <div
        ref={editorRef}
        contentEditable
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        data-cell-column={column}
        className="w-full min-h-[2.5rem] bg-transparent focus:bg-yellow-50 focus:ring-2 focus:ring-purple-400 rounded-lg px-3 py-2 cursor-text text-sm"
        style={{ wordWrap: 'break-word', whiteSpace: 'pre-wrap' }}
        suppressContentEditableWarning
      />
      {!value && (
        <div className="absolute top-2 left-3 text-gray-400 pointer-events-none select-none text-sm italic">
          {placeholder}
        </div>
      )}
    </div>
  );
}

function CommentViewer() {
  const [expandedComments, setExpandedComments] = useState(new Set());
  const [collapsedColumns, setCollapsedColumns] = useState(new Set());
  const [comments, setComments] = useState([]);
  const [officeReady, setOfficeReady] = useState(false);
  const [loading, setLoading] = useState(true);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCommentId, setNewCommentId] = useState('');
  const [newCommentLocation, setNewCommentLocation] = useState('');
  const [columnWidths, setColumnWidths] = useState({
    admin: 300,
    proof: 300,
    galley: 300
  });
  const [selectedCommentId, setSelectedCommentId] = useState(null);
  const [lastSaveTime, setLastSaveTime] = useState(Date.now());
  const saveTimeoutRef = useRef(null);
  const commentIdInputRef = useRef(null);

  const applyFormat = (command) => {
    document.execCommand(command, false, null);
  };

  const applyHighlight = () => {
    document.execCommand('hiliteColor', false, 'yellow');
  };

  useEffect(() => {
    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        setOfficeReady(true);
        loadCommentsFromWord();
      }
    });
  }, []);

  useEffect(() => {
    if (!officeReady || comments.length === 0) return;
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveCommentsToWordSilent();
    }, 2000);
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [comments, officeReady]);

  async function loadCommentsFromWord() {
    setLoading(true);
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          const commentData = [];
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            const range = comment.getRange();
            range.load("start");
            await context.sync();

            const content = comment.content;
            let commentId, tableData;
            if (content.includes('|||')) {
              const parts = content.split('|||');
              commentId = parts[0];
              try {
                tableData = JSON.parse(parts[1]);
              } catch (e) {
                console.error("Error parsing comment data:", e);
                tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
              }
            } else {
              commentId = content;
              tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
            }

            commentData.push({
              id: commentId,
              position: range.start,
              location: `Position ${range.start}`,
              timestamp: new Date().toISOString().split('T')[0],
              items: tableData.items
            });
          }

          commentData.sort((a, b) => a.position - b.position);
          setComments(commentData);

          if (commentData.length > 0) {
            setExpandedComments(new Set([commentData[0].id]));
          }
        });
      } catch (error) {
        console.error("Error loading comments:", error);
        alert("Error loading comments: " + error.message);
      } finally {
        setLoading(false);
      }
    }, 100);
  }

  function saveCommentsToWordSilent() {
    if (!officeReady) return;
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          for (let i = 0; i < wordComments.items.length; i++) {
            const wordComment = wordComments.items[i];
            wordComment.load("content");
            await context.sync();

            const currentContent = wordComment.content;
            const commentId = currentContent.includes('|||') ? currentContent.split('|||')[0] : currentContent;
            const ourComment = comments.find(c => c.id === commentId);

            if (ourComment) {
              const newContent = `${ourComment.id}|||${JSON.stringify({ items: ourComment.items })}`;
              if (wordComment.content !== newContent) {
                wordComment.content = newContent;
              }
            }
          }

          await context.sync();
          setLastSaveTime(Date.now());
        });
      } catch (error) {
        console.error("Error auto-saving:", error);
      }
    }, 100);
  }

  function saveCommentsToWord() {
    if (!officeReady) {
      alert("Please wait for Office to finish loading");
      return;
    }
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const properties = context.document.properties;
          const customProps = properties.customProperties;
          const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
          await context.sync();

          const commentsJson = JSON.stringify(comments);

          if (commentsProp.isNullObject) {
            customProps.add("lawReviewComments", commentsJson);
          } else {
            commentsProp.value = commentsJson;
          }

          await context.sync();
          setLastSaveTime(Date.now());
          alert("Comments saved successfully!");
        });
      } catch (error) {
        console.error("Error saving comments:", error);
        alert("Error saving comments: " + error.message);
      }
    }, 100);
  }

  function createNewCommentFromSelection() {
    if (!officeReady) {
      alert("Please wait for Office to finish loading");
      return;
    }
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          range.load("text");
          await context.sync();

          if (range.text.length === 0) {
            alert("Please select some text first!");
            return;
          }

          let locationText = range.text.substring(0, 50);
          if (range.text.length > 50) {
            locationText += "...";
          }

          setNewCommentLocation(`Text: "${locationText}"`);
          setShowCreateDialog(true);
        });
      } catch (error) {
        console.error("Error creating comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function finalizeCreateComment() {
    if (!newCommentId.trim()) {
      alert("Please enter a comment ID!");
      return;
    }
    if (comments.some(c => c.id === newCommentId)) {
      alert("A comment with this ID already exists!");
      return;
    }

    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          const comment = range.insertComment(newCommentId);
          await context.sync();

          const newComment = {
            id: newCommentId,
            location: newCommentLocation,
            timestamp: new Date().toISOString().split('T')[0] + " " + new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
            items: [{ id: "1", admin: "", proof: "", galley: "" }]
          };

          const updatedComments = [...comments, newComment];
          setComments(updatedComments);

          const newExpanded = new Set(expandedComments);
          newExpanded.add(newCommentId);
          setExpandedComments(newExpanded);

          const properties = context.document.properties;
          const customProps = properties.customProperties;
          const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
          await context.sync();

          if (commentsProp.isNullObject) {
            customProps.add("lawReviewComments", JSON.stringify(updatedComments));
          } else {
            commentsProp.value = JSON.stringify(updatedComments);
          }

          await context.sync();

          setShowCreateDialog(false);
          setNewCommentId('');
          setNewCommentLocation('');

          alert("Comment created successfully! You'll see it in Word's margin.");
        });
      } catch (error) {
        console.error("Error finalizing comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function jumpToComment(commentId) {
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const comments = context.document.body.getComments();
          comments.load("items");
          await context.sync();

          let found = false;
          for (let i = 0; i < comments.items.length; i++) {
            const comment = comments.items[i];
            comment.load("content");
            await context.sync();

            if (comment.content === commentId) {
              const range = comment.getRange();
              range.select();
              found = true;
              break;
            }
          }

          if (!found) {
            alert("Could not find this comment in the document.");
          }
        });
      } catch (error) {
        console.error("Error jumping to comment:", error);
        alert("Error navigating to comment: " + error.message);
      }
    }, 100);
  }

  const allEditors = ['All', 'Admin', 'Proof', 'Galley'];

  const filteredComments = useMemo(() => {
    return comments;
  }, [comments]);

  const toggleExpand = (commentId) => {
    const newExpanded = new Set(expandedComments);
    if (newExpanded.has(commentId)) {
      newExpanded.delete(commentId);
    } else {
      newExpanded.add(commentId);
    }
    setExpandedComments(newExpanded);
  };

  const toggleColumn = (columnName) => {
    const newCollapsed = new Set(collapsedColumns);
    if (newCollapsed.has(columnName)) {
      newCollapsed.delete(columnName);
    } else {
      newCollapsed.add(columnName);
    }
    setCollapsedColumns(newCollapsed);
  };

  const addRowAfter = (commentId, afterIndex) => {
    setComments(comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems.splice(afterIndex + 1, 0, { id: "", admin: "", proof: "", galley: "" });
        return { ...comment, items: newItems };
      }
      return comment;
    }));
  };

  const updateCell = (commentId, itemIndex, column, value) => {
    setComments(comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems[itemIndex] = { ...newItems[itemIndex], [column]: value };
        return { ...comment, items: newItems };
      }
      return comment;
    }));
  };

  const deleteRow = (commentId, itemIndex) => {
    setComments(comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = comment.items.filter((_, idx) => idx !== itemIndex);
        return { ...comment, items: newItems };
      }
      return comment;
    }));
  };

  // Handle Enter key in dialog
  const handleDialogKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finalizeCreateComment();
    }
  };

  // Focus the input when dialog opens
  useEffect(() => {
    if (showCreateDialog && commentIdInputRef.current) {
      commentIdInputRef.current.focus();
    }
  }, [showCreateDialog]);

  const ChevronDown = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  );
  const ChevronUp = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  );

  return (
    <div className="h-screen flex flex-col bg-gradient-to-br from-purple-600 via-indigo-600 to-blue-600">
      {/* Header with gradient */}
      <div className="glass shadow-2xl p-4">
        <h1 className="text-xl font-bold mb-3 text-center bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">
          üìù Law Review Comments
        </h1>
        <div className="flex items-center justify-between gap-2">
          <div className="flex gap-2">
            <button onClick={() => applyFormat('bold')}
              className="px-3 py-1.5 bg-white hover:bg-purple-50 rounded-lg font-bold text-sm shadow-sm hover:shadow-md border border-purple-200"
              title="Bold">B</button>
            <button onClick={() => applyFormat('italic')}
              className="px-3 py-1.5 bg-white hover:bg-purple-50 rounded-lg italic text-sm shadow-sm hover:shadow-md border border-purple-200"
              title="Italic">I</button>
            <button onClick={applyHighlight}
              className="px-3 py-1.5 bg-yellow-200 hover:bg-yellow-300 rounded-lg text-sm shadow-sm hover:shadow-md border border-yellow-300"
              title="Highlight">H</button>
            <button onClick={() => applyFormat('removeFormat')}
              className="px-3 py-1.5 bg-white hover:bg-red-50 rounded-lg text-sm text-red-500 shadow-sm hover:shadow-md border border-red-200"
              title="Clear">‚úï</button>
          </div>
          
          <div className="flex gap-2">
            <button onClick={createNewCommentFromSelection}
              className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-4 py-1.5 rounded-lg text-sm font-medium shadow-md hover:shadow-lg"
              style={{ cursor: 'pointer' }}>+ New</button>
            <button onClick={loadCommentsFromWord}
              className="bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-600 hover:to-indigo-600 text-white px-4 py-1.5 rounded-lg text-sm font-medium shadow-md hover:shadow-lg"
              style={{ cursor: 'pointer' }}>üîÑ Refresh</button>
          </div>
        </div>
      </div>

      {/* Create Dialog with improved styling */}
      {showCreateDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 backdrop-blur-sm">
          <div className="glass rounded-2xl p-8 max-w-md w-full mx-4 shadow-2xl">
            <h2 className="text-2xl font-bold mb-6 bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">Create New Comment</h2>
            <div className="mb-5">
              <label className="block text-sm font-semibold text-gray-700 mb-2">
                Comment ID (e.g., "125A")
              </label>
              <input 
                ref={commentIdInputRef}
                type="text" 
                value={newCommentId} 
                onChange={(e) => setNewCommentId(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-4 py-3 border-2 border-purple-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent shadow-sm"
                placeholder="125A" 
              />
            </div>
            <div className="mb-6">
              <label className="block text-sm font-semibold text-gray-700 mb-2">Location</label>
              <input 
                type="text" 
                value={newCommentLocation} 
                onChange={(e) => setNewCommentLocation(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-4 py-3 border-2 border-purple-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent shadow-sm" 
              />
              <p className="mt-2 text-xs text-gray-600 bg-purple-50 p-2 rounded-lg">
                üí° A Word comment will appear in the margin. To delete later, just delete the Word comment and click Refresh.
              </p>
            </div>
            <div className="flex gap-3 justify-end">
              <button 
                onClick={() => { setShowCreateDialog(false); setNewCommentId(''); setNewCommentLocation(''); }}
                className="px-6 py-2.5 border-2 border-gray-300 rounded-lg hover:bg-gray-50 font-medium shadow-sm hover:shadow">
                Cancel
              </button>
              <button 
                onClick={finalizeCreateComment}
                className="px-6 py-2.5 bg-gradient-to-r from-purple-500 to-indigo-500 text-white rounded-lg hover:from-purple-600 hover:to-indigo-600 font-medium shadow-md hover:shadow-lg">
                Create Comment
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Comments List with improved cards */}
      <div className="flex-1 overflow-y-auto p-4">
        {loading ? (
          <div className="text-center text-white mt-12">
            <div className="inline-block animate-spin rounded-full h-12 w-12 border-4 border-white border-t-transparent mb-4"></div>
            <p className="text-lg font-medium">Loading comments...</p>
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center text-white mt-12 glass p-8 rounded-2xl max-w-md mx-auto">
            <p className="text-2xl mb-3">üìã No comments yet!</p>
            <p className="text-sm mb-2">Select some text and click "New Comment" to get started.</p>
            <p className="text-xs mt-4 text-purple-100">üí° Tip: Delete comments by right-clicking the Word comment in the margin, then click Refresh here.</p>
          </div>
        ) : filteredComments.length === 0 ? (
          <div className="text-center text-white mt-12">No comments found.</div>
        ) : (
          filteredComments.map(comment => (
            <div
              key={comment.id}
              id={`comment-${comment.id}`}
              className="mb-4 glass rounded-xl shadow-lg comment-card overflow-hidden hover:shadow-2xl"
            >
              {/* Comment Header */}
              <div className="p-4 bg-gradient-to-r from-purple-50 to-indigo-50 border-b-2 border-purple-200 flex items-center justify-between gap-2">
                <div className="flex items-center gap-3 flex-1 cursor-pointer hover:bg-purple-100 p-2 rounded-lg"
                  onClick={() => toggleExpand(comment.id)}>
                  {expandedComments.has(comment.id) ? <ChevronUp /> : <ChevronDown />}
                  <div className="text-sm">
                    <span
                      className="font-bold text-lg text-purple-700 cursor-pointer hover:text-purple-900 hover:underline"
                      onClick={(e) => {
                        e.stopPropagation();
                        jumpToComment(comment.id);
                      }}
                    >
                      {comment.id}
                    </span>
                    <span className="mx-2 text-purple-300">‚Ä¢</span>
                    <span className="text-gray-600">{comment.location}</span>
                  </div>
                </div>
                <div className="flex items-center gap-2 shrink-0">
                  <span className="text-xs text-gray-500 bg-white px-3 py-1 rounded-full font-medium shadow-sm">
                    {comment.items.length} item{comment.items.length !== 1 ? 's' : ''}
                  </span>
                </div>
              </div>

              {/* Expanded Table */}
              {expandedComments.has(comment.id) && (
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead className="bg-gradient-to-r from-purple-100 to-indigo-100 border-b-2 border-purple-300">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-bold text-purple-800 border-r border-purple-200 w-28">Item #</th>
                        {[
                          { key: 'admin', label: 'Admin' },
                          { key: 'proof', label: 'Proof' },
                          { key: 'galley', label: 'Galley' }
                        ].map(({ key, label }) => (
                          !collapsedColumns.has(key) && (
                            <th key={key}
                              className="px-4 py-3 text-left text-xs font-bold text-purple-800 border-r border-purple-200 cursor-pointer hover:bg-purple-200 group"
                              style={{ minWidth: '300px' }} 
                              onClick={(e) => { e.stopPropagation(); toggleColumn(key); }}>
                              <div className="flex items-center justify-between">
                                <span>{label}</span><ChevronUp />
                              </div>
                            </th>
                          )
                        ))}
                        {collapsedColumns.size > 0 && (
                          <th className="px-2 py-2 text-center text-xs font-semibold text-gray-500 border-r border-purple-200">
                            <div className="flex flex-col gap-1">
                              {Array.from(collapsedColumns).map(col => (
                                <button key={col} onClick={(e) => { e.stopPropagation(); toggleColumn(col); }}
                                  className="px-2 py-1 bg-purple-200 hover:bg-purple-300 rounded-lg text-xs flex items-center gap-1 font-medium shadow-sm">
                                  <ChevronDown /> {col.charAt(0).toUpperCase() + col.slice(1)}
                                </button>
                              ))}
                            </div>
                          </th>
                        )}
                        <th className="px-2 py-2 w-12"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {comment.items.map((item, idx) => (
                        <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-purple-25'}>
                          <td className="px-3 py-2 text-sm font-bold text-purple-700 border-r border-purple-100 align-top">
                            <input type="text" value={item.id} onChange={(e) => updateCell(comment.id, idx, 'id', e.target.value)}
                              className="w-full bg-transparent border-none focus:outline-none focus:ring-2 focus:ring-purple-300 rounded-lg px-2 py-1 text-sm"
                              placeholder="ID" />
                          </td>
                          {!collapsedColumns.has('admin') && (
                            <td className="px-3 py-2 text-gray-800 border-r border-purple-100 align-top">
                              <RichTextCell value={item.admin} onChange={(html) => updateCell(comment.id, idx, 'admin', html)} 
                                        placeholder="‚Äî" commentId={comment.id} itemIndex={idx} column="admin" />
                                    </td>
                                  )}
                                  {!collapsedColumns.has('proof') && (
                                    <td className="px-2 py-1 text-gray-800 border-r border-gray-200 align-top">
                                      <RichTextCell value={item.proof} onChange={(html) => updateCell(comment.id, idx, 'proof', html)} 
                                        placeholder="‚Äî" commentId={comment.id} itemIndex={idx} column="proof" />
                                    </td>
                                  )}
                                  {!collapsedColumns.has('galley') && (
                                    <td className="px-2 py-1 text-gray-800 border-r border-gray-200 align-top">
                                      <RichTextCell value={item.galley} onChange={(html) => updateCell(comment.id, idx, 'galley', html)} 
                                        placeholder="‚Äî" commentId={comment.id} itemIndex={idx} column="galley" />
                                    </td>
                                  )}
                                  {collapsedColumns.size > 0 && <td className="border-r border-gray-200"></td>}
                                  <td className="px-1 py-1 text-center align-top">
                                    <div className="flex flex-col gap-0.5">
                                      <button type="button" onClick={() => addRowAfter(comment.id, idx)}
                                        className="text-blue-600 hover:text-blue-800 hover:bg-blue-50 p-0.5 rounded transition text-xs" title="Add row below">
                                        +
                                      </button>
                                      <button type="button" onClick={() => deleteRow(comment.id, idx)}
                                        className="text-red-600 hover:text-red-800 hover:bg-red-50 p-0.5 rounded transition text-xs font-bold" title="Delete row">
                                        √ó
                                      </button>
                                    </div>
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      )}
                    </div>
                  ))
                )}
              </div>

              {/* Footer - Compact */}
              <div className="bg-gray-100 border-t border-gray-300 px-2 py-1 text-xs text-gray-600">
                {officeReady ? "‚úì Ready" : "‚ö† Loading..."} ‚Ä¢ 
                {filteredComments.length} comment{filteredComments.length !== 1 ? 's' : ''} ‚Ä¢ 
                Data stored in Word comments ‚Ä¢ Copy/paste works!
              </div>
            </div>
          );
        }

        ReactDOM.render(<CommentViewer />, document.getElementById('root'));
    </script>
</body>
</html>
