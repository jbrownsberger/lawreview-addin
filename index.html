<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Law Review Comment Viewer - v36</title>

<script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
body { 
  margin: 0; 
  padding: 0; 
  font-family: Helvetica, Arial, sans-serif;
  background: #f8f9fa;
}
[contenteditable] { outline: none; }
[contenteditable]:focus { background-color: #f0f0f0; }

::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #f1f1f1;
}
::-webkit-scrollbar-thumb {
  background: #6b7280;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #4b5563;
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
console.log("Law Review Add-in Version 36 - Clean design + Enter to submit!");

const { useState, useEffect, useMemo, useRef } = React;

function RichTextCell({ value, onChange, placeholder, commentId, itemIndex, column }) {
  const editorRef = useRef(null);
  const isUpdatingRef = useRef(false);

  useEffect(() => {
    if (editorRef.current && !editorRef.current.innerHTML) {
      editorRef.current.innerHTML = value || '';
    }
  }, []);

  useEffect(() => {
    if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
      const currentHtml = editorRef.current.innerHTML;
      if (currentHtml !== value && value !== undefined) {
        editorRef.current.innerHTML = value || '';
      }
    }
  }, [value]);

  const handleInput = (e) => {
    isUpdatingRef.current = true;
    const newHtml = e.target.innerHTML;
    onChange(newHtml);
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  };

  const handleKeyDown = (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'b') {
      e.preventDefault();
      document.execCommand('bold', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'i') {
      e.preventDefault();
      document.execCommand('italic', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
      e.preventDefault();
      document.execCommand('underline', false, null);
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      const allCells = Array.from(document.querySelectorAll(`[data-cell-column="${column}"]`));
      const currentIndex = allCells.indexOf(editorRef.current);
      if (currentIndex >= 0 && currentIndex < allCells.length - 1) {
        const nextCell = allCells[currentIndex + 1];
        nextCell.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        if (nextCell.childNodes.length > 0) {
          range.selectNodeContents(nextCell);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    }
  };

  return (
    <div className="relative w-full">
      <div
        ref={editorRef}
        contentEditable
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        data-cell-column={column}
        className="w-full min-h-[1.5rem] bg-transparent focus:bg-gray-100 focus:ring-1 focus:ring-gray-400 rounded px-2 py-0.5 cursor-text text-sm"
        style={{ wordWrap: 'break-word', whiteSpace: 'pre-wrap' }}
        suppressContentEditableWarning
      />
      {!value && (
        <div className="absolute top-1 left-2 text-gray-400 pointer-events-none select-none text-sm italic">
          {placeholder}
        </div>
      )}
    </div>
  );
}

function CommentViewer() {
  const [expandedComments, setExpandedComments] = useState(new Set());
  const [collapsedColumns, setCollapsedColumns] = useState(new Set());
  const [comments, setComments] = useState([]);
  const [officeReady, setOfficeReady] = useState(false);
  const [loading, setLoading] = useState(true);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCommentId, setNewCommentId] = useState('');
  const [newCommentLocation, setNewCommentLocation] = useState('');
  const [lastSaveTime, setLastSaveTime] = useState(Date.now());
  const saveTimeoutRef = useRef(null);
  const commentIdInputRef = useRef(null);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);

  const applyFormat = (command) => {
    document.execCommand(command, false, null);
  };

  const applyHighlight = () => {
    document.execCommand('hiliteColor', false, 'yellow');
  };

  const saveToHistory = (newComments) => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(JSON.parse(JSON.stringify(newComments)));
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const previousState = history[historyIndex - 1];
      setComments(JSON.parse(JSON.stringify(previousState)));
      setHistoryIndex(historyIndex - 1);
    }
  };

  useEffect(() => {
    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        setOfficeReady(true);
        loadCommentsFromWord();
      }
    });
  }, []);

  useEffect(() => {
    if (!officeReady || comments.length === 0) return;
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveCommentsToWordSilent();
    }, 2000);
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [comments, officeReady]);

  async function loadCommentsFromWord() {
    setLoading(true);
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          const commentData = [];
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            const range = comment.getRange();
            range.load("start");
            await context.sync();

            const content = comment.content;
            let commentId, tableData;
            if (content.includes('|||')) {
              const parts = content.split('|||');
              commentId = parts[0];
              try {
                tableData = JSON.parse(parts[1]);
              } catch (e) {
                console.error("Error parsing comment data:", e);
                tableData = { items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false }] };
              }
            } else {
              commentId = content;
              tableData = { items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false }] };
            }

            commentData.push({
              id: commentId,
              position: range.start,
              location: `Position ${range.start}`,
              timestamp: new Date().toISOString().split('T')[0],
              items: tableData.items
            });
          }

          commentData.sort((a, b) => a.position - b.position);
          setComments(commentData);

          if (commentData.length > 0) {
            setExpandedComments(new Set([commentData[0].id]));
          }
        });
      } catch (error) {
        console.error("Error loading comments:", error);
        alert("Error loading comments: " + error.message);
      } finally {
        setLoading(false);
      }
    }, 100);
  }

  function saveCommentsToWordSilent() {
    if (!officeReady) return;
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          for (let i = 0; i < wordComments.items.length; i++) {
            const wordComment = wordComments.items[i];
            wordComment.load("content");
            await context.sync();

            const currentContent = wordComment.content;
            const commentId = currentContent.includes('|||') ? currentContent.split('|||')[0] : currentContent;
            const ourComment = comments.find(c => c.id === commentId);

            if (ourComment) {
              const newContent = `${ourComment.id}|||${JSON.stringify({ items: ourComment.items })}`;
              if (wordComment.content !== newContent) {
                wordComment.content = newContent;
              }
            }
          }

          await context.sync();
          setLastSaveTime(Date.now());
        });
      } catch (error) {
        console.error("Error auto-saving:", error);
      }
    }, 100);
  }

  function createNewCommentFromSelection() {
    if (!officeReady) {
      alert("Please wait for Office to finish loading");
      return;
    }
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          range.load("text");
          await context.sync();

          if (range.text.length === 0) {
            alert("Please select some text first!");
            return;
          }

          let locationText = range.text.substring(0, 50);
          if (range.text.length > 50) {
            locationText += "...";
          }

          setNewCommentLocation(`Text: "${locationText}"`);
          setShowCreateDialog(true);
        });
      } catch (error) {
        console.error("Error creating comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function finalizeCreateComment() {
    if (!newCommentId.trim()) {
      alert("Please enter a comment ID!");
      return;
    }
    if (comments.some(c => c.id === newCommentId)) {
      alert("A comment with this ID already exists!");
      return;
    }

    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          const comment = range.insertComment(newCommentId);
          await context.sync();

          const newComment = {
            id: newCommentId,
            location: newCommentLocation,
            timestamp: new Date().toISOString().split('T')[0] + " " + new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
            items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false }]
          };

          const updatedComments = [...comments, newComment];
          setComments(updatedComments);

          const newExpanded = new Set(expandedComments);
          newExpanded.add(newCommentId);
          setExpandedComments(newExpanded);

          const properties = context.document.properties;
          const customProps = properties.customProperties;
          const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
          await context.sync();

          if (commentsProp.isNullObject) {
            customProps.add("lawReviewComments", JSON.stringify(updatedComments));
          } else {
            commentsProp.value = JSON.stringify(updatedComments);
          }

          await context.sync();

          setShowCreateDialog(false);
          setNewCommentId('');
          setNewCommentLocation('');

          alert("Comment created successfully! You'll see it in Word's margin.");
        });
      } catch (error) {
        console.error("Error finalizing comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function jumpToComment(commentId) {
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          let found = false;
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            await context.sync();

            const content = comment.content;
            const actualCommentId = content.includes('|||') ? content.split('|||')[0] : content;

            if (actualCommentId === commentId) {
              const range = comment.getRange();
              range.select();
              found = true;
              break;
            }
          }

          if (!found) {
            alert("Could not find this comment in the document.");
          }
        });
      } catch (error) {
        console.error("Error jumping to comment:", error);
        alert("Error navigating to comment: " + error.message);
      }
    }, 100);
  }

  const filteredComments = useMemo(() => {
    return comments;
  }, [comments]);

  const toggleExpand = (commentId) => {
    const newExpanded = new Set(expandedComments);
    if (newExpanded.has(commentId)) {
      newExpanded.delete(commentId);
    } else {
      newExpanded.add(commentId);
    }
    setExpandedComments(newExpanded);
  };

  const toggleColumn = (columnName) => {
    const newCollapsed = new Set(collapsedColumns);
    if (newCollapsed.has(columnName)) {
      newCollapsed.delete(columnName);
    } else {
      newCollapsed.add(columnName);
    }
    setCollapsedColumns(newCollapsed);
  };

  const addRowAfter = (commentId, afterIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems.splice(afterIndex + 1, 0, { id: "", admin: "", proof: "", galley: "", isHeading: false });
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const toggleHeading = (commentId, itemIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems[itemIndex] = { ...newItems[itemIndex], isHeading: !newItems[itemIndex].isHeading };
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const updateCell = (commentId, itemIndex, column, value) => {
    setComments(comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems[itemIndex] = { ...newItems[itemIndex], [column]: value };
        return { ...comment, items: newItems };
      }
      return comment;
    }));
  };

  const deleteRow = (commentId, itemIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = comment.items.filter((_, idx) => idx !== itemIndex);
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const handleDialogKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finalizeCreateComment();
    }
  };

  useEffect(() => {
    if (showCreateDialog && commentIdInputRef.current) {
      commentIdInputRef.current.focus();
    }
  }, [showCreateDialog]);

  const ChevronDown = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  );
  const ChevronUp = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  );

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      <div className="bg-gray-100 border-b border-gray-300 px-3 py-2">
        <div className="flex items-center justify-between gap-2 mb-2">
          <h1 className="text-sm font-semibold text-gray-700">Law Review Comments</h1>
          <div className="flex gap-1">
            <button onClick={createNewCommentFromSelection}
              className="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs font-medium"
              style={{ cursor: 'pointer' }}>+ New</button>
            <button onClick={loadCommentsFromWord}
              className="bg-indigo-500 hover:bg-indigo-600 text-white px-2 py-1 rounded text-xs font-medium"
              style={{ cursor: 'pointer' }}>â†» Refresh</button>
            <button onClick={undo}
              disabled={historyIndex <= 0}
              className={`${historyIndex <= 0 ? 'bg-gray-300 cursor-not-allowed' : 'bg-amber-500 hover:bg-amber-600'} text-white px-2 py-1 rounded text-xs font-medium`}
              style={{ cursor: historyIndex <= 0 ? 'not-allowed' : 'pointer' }}
              title="Undo">âŽŒ Undo</button>
          </div>
        </div>
        <div className="flex gap-1">
          <button onClick={() => applyFormat('bold')}
            className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded font-bold text-xs"
            title="Bold">B</button>
          <button onClick={() => applyFormat('italic')}
            className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded italic text-xs"
            title="Italic">I</button>
          <button onClick={applyHighlight}
            className="px-2 py-0.5 bg-yellow-100 hover:bg-yellow-200 border border-yellow-300 rounded text-xs"
            title="Highlight">H</button>
          <button onClick={() => applyFormat('removeFormat')}
            className="px-2 py-0.5 bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded text-xs text-red-600"
            title="Clear">âœ•</button>
        </div>
      </div>

      {showCreateDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Create New Comment</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Comment ID (e.g., "125A")
              </label>
              <input 
                ref={commentIdInputRef}
                type="text" 
                value={newCommentId} 
                onChange={(e) => setNewCommentId(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
                placeholder="125A" 
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">Location</label>
              <input 
                type="text" 
                value={newCommentLocation} 
                onChange={(e) => setNewCommentLocation(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent" 
              />
              <p className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                ðŸ’¡ A Word comment will appear in the margin. To delete later, just delete the Word comment and click Refresh.
              </p>
            </div>
            <div className="flex gap-2 justify-end">
              <button 
                onClick={() => { setShowCreateDialog(false); setNewCommentId(''); setNewCommentLocation(''); }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm">
                Cancel
              </button>
              <button 
                onClick={finalizeCreateComment}
                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm font-medium">
                Create Comment
              </button>
            </div>
          </div>
        </div>
      )}

      <div className="flex-1 overflow-y-auto p-2">
        {loading ? (
          <div className="text-center text-gray-500 mt-8">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-2 border-gray-300 border-t-gray-600 mb-2"></div>
            <p className="text-sm">Loading comments...</p>
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8 bg-white p-6 rounded border border-gray-200 max-w-sm mx-auto">
            <p className="text-base mb-2">ðŸ“‹ No comments yet</p>
            <p className="text-xs mb-1">Select some text and click "New Comment" to get started.</p>
            <p className="text-xs mt-3 text-gray-400">ðŸ’¡ Tip: Delete comments by right-clicking the Word comment in the margin, then click Refresh here.</p>
          </div>
        ) : filteredComments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">No comments found.</div>
        ) : (
          filteredComments.map(comment => (
            <div
              key={comment.id}
              id={`comment-${comment.id}`}
              className="mb-2 bg-white rounded border border-gray-200 shadow-sm"
            >
              <div className="px-2 py-1.5 bg-gray-50 border-b border-gray-200 flex items-center justify-between gap-2">
                <div className="flex items-center gap-2 flex-1 cursor-pointer hover:bg-gray-100 px-1 py-0.5 rounded"
                  onClick={() => toggleExpand(comment.id)}>
                  {expandedComments.has(comment.id) ? <ChevronUp /> : <ChevronDown />}
                  <div className="text-xs">
                    <span
                      className="font-semibold text-gray-700 cursor-pointer hover:underline"
                      onClick={(e) => {
                        e.stopPropagation();
                        jumpToComment(comment.id);
                      }}
                    >
                      {comment.id}
                    </span>
                    <span className="mx-1 text-gray-400">â€¢</span>
                    <span className="text-gray-600">{comment.location}</span>
                  </div>
                </div>
                <div className="flex items-center gap-2 shrink-0">
                  <span className="text-xs text-gray-500 bg-white px-2 py-0.5 rounded border border-gray-200">
                    {comment.items.length} item{comment.items.length !== 1 ? 's' : ''}
                  </span>
                </div>
              </div>

              {expandedComments.has(comment.id) && (
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse text-xs">
                    <thead className="bg-gray-100 border-b border-gray-300">
                      <tr>
                        <th className="px-2 py-1.5 text-left font-semibold text-gray-700 border-r border-gray-200 w-20">Item #</th>
                        {[
                          { key: 'admin', label: 'Admin' },
                          { key: 'proof', label: 'Proof' },
                          { key: 'galley', label: 'Galley' }
                        ].map(({ key, label }) => (
                          !collapsedColumns.has(key) && (
                            <th key={key}
                              className="px-2 py-1.5 text-left font-semibold text-gray-700 border-r border-gray-200 cursor-pointer hover:bg-gray-200"
                              style={{ minWidth: '250px' }} 
                              onClick={(e) => { e.stopPropagation(); toggleColumn(key); }}>
                              <div className="flex items-center justify-between">
                                <span>{label}</span><ChevronUp />
                              </div>
                            </th>
                          )
                        ))}
                        {collapsedColumns.size > 0 && (
                          <th className="px-1 py-1 text-center font-semibold text-gray-500 border-r border-gray-200">
                            <div className="flex flex-col gap-0.5">
                              {Array.from(collapsedColumns).map(col => (
                                <button key={col} onClick={(e) => { e.stopPropagation(); toggleColumn(col); }}
                                  className="px-1.5 py-0.5 bg-gray-200 hover:bg-gray-300 rounded text-xs flex items-center gap-1">
                                  <ChevronDown /> {col.charAt(0).toUpperCase() + col.slice(1)}
                                </button>
                              ))}
                            </div>
                          </th>
                        )}
                        <th className="px-1 py-1 w-8"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {comment.items.map((item, idx) => (
                        <tr key={idx} className={item.isHeading ? 'bg-blue-50' : (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50')}>
                          <td className="px-2 py-0.5 font-semibold text-gray-700 border-r border-gray-200 align-top">
                            <input type="text" value={item.id} onChange={(e) => updateCell(comment.id, idx, 'id', e.target.value)}
                              className={`w-full bg-transparent border-none focus:outline-none focus:ring-1 focus:ring-gray-500 rounded px-1 text-xs ${item.isHeading ? 'font-bold' : ''}`}
                              placeholder="ID" />
                          </td>
                          {!collapsedColumns.has('admin') && (
                            <td className="px-2 py-0.5 text-gray-800 border-r border-gray-200 align-top">
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.admin} onChange={(html) => updateCell(comment.id, idx, 'admin', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="admin" />
                              </div>
                            </td>
                          )}
                          {!collapsedColumns.has('proof') && (
                            <td className="px-2 py-0.5 text-gray-800 border-r border-gray-200 align-top">
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.proof} onChange={(html) => updateCell(comment.id, idx, 'proof', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="proof" />
                              </div>
                            </td>
                          )}
                          {!collapsedColumns.has('galley') && (
                            <td className="px-2 py-0.5 text-gray-800 border-r border-gray-200 align-top">
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.galley} onChange={(html) => updateCell(comment.id, idx, 'galley', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="galley" />
                              </div>
                            </td>
                          )}
                          {collapsedColumns.size > 0 && <td className="border-r border-gray-200"></td>}
                          <td className="px-1 py-0.5 text-center align-top">
                            <div className="flex flex-col gap-0.5">
                              <button type="button" onClick={() => toggleHeading(comment.id, idx)}
                                className={`${item.isHeading ? 'text-blue-600' : 'text-gray-500'} hover:text-blue-800 hover:bg-blue-50 p-0.5 rounded text-xs font-bold`} 
                                title={item.isHeading ? "Convert to regular row" : "Convert to heading"}>
                                H
                              </button>
                              <button type="button" onClick={() => addRowAfter(comment.id, idx)}
                                className="text-blue-600 hover:text-blue-800 hover:bg-blue-50 p-0.5 rounded text-xs" title="Add row below">
                                +
                              </button>
                              <button type="button" onClick={() => deleteRow(comment.id, idx)}
                                className="text-red-600 hover:text-red-800 hover:bg-red-50 p-0.5 rounded text-xs font-bold" title="Delete row">
                                Ã—
                              </button>
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          ))
        )}
      </div>

      <div className="bg-white border-t border-gray-300 px-2 py-1 text-xs text-gray-600">
        {officeReady ? "âœ“ Ready" : "âš  Loading..."} â€¢ 
        {filteredComments.length} comment{filteredComments.length !== 1 ? 's' : ''} â€¢ 
        Data stored in Word comments
      </div>
    </div>
  );
}

ReactDOM.render(<CommentViewer />, document.getElementById('root'));
</script>
</body>
</html>
