<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Law Review Comment Viewer - v34 COMMENT DATA</title></title>
    
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; }
        [contenteditable] { outline: none; }
        [contenteditable]:focus { background-color: #f9fafb; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        console.log("Law Review Add-in Version 34 - Data in Word comments!");
        
        const { useState, useEffect, useMemo, useRef } = React;

        // Rich text cell component - COMPLETELY REWRITTEN
        function RichTextCell({ value, onChange, placeholder, commentId, itemIndex, column }) {
          const editorRef = useRef(null);
          const isUpdatingRef = useRef(false);
          
          // Initialize content only once
          useEffect(() => {
            if (editorRef.current && !editorRef.current.innerHTML) {
              editorRef.current.innerHTML = value || '';
            }
          }, []);
          
          // Only update if value changes from outside AND we're not currently editing
          useEffect(() => {
            if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
              const currentHtml = editorRef.current.innerHTML;
              if (currentHtml !== value && value !== undefined) {
                editorRef.current.innerHTML = value || '';
              }
            }
          }, [value]);
          
          const handleInput = (e) => {
            isUpdatingRef.current = true;
            const newHtml = e.target.innerHTML;
            onChange(newHtml);
            setTimeout(() => {
              isUpdatingRef.current = false;
            }, 0);
          };
          
          const handleKeyDown = (e) => {
            // Cmd/Ctrl + B = Bold
            if ((e.metaKey || e.ctrlKey) && e.key === 'b') {
              e.preventDefault();
              document.execCommand('bold', false, null);
              return;
            }
            
            // Cmd/Ctrl + I = Italic
            if ((e.metaKey || e.ctrlKey) && e.key === 'i') {
              e.preventDefault();
              document.execCommand('italic', false, null);
              return;
            }
            
            // Cmd/Ctrl + U = Underline (in case they want it)
            if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
              e.preventDefault();
              document.execCommand('underline', false, null);
              return;
            }
            
            // Tab key = move to cell below
            if (e.key === 'Tab') {
              e.preventDefault();
              
              // Find all editable cells in this column
              const allCells = Array.from(document.querySelectorAll(`[data-cell-column="${column}"]`));
              const currentIndex = allCells.indexOf(editorRef.current);
              
              if (currentIndex >= 0 && currentIndex < allCells.length - 1) {
                const nextCell = allCells[currentIndex + 1];
                nextCell.focus();
                
                // Place cursor at end
                const range = document.createRange();
                const sel = window.getSelection();
                if (nextCell.childNodes.length > 0) {
                  range.selectNodeContents(nextCell);
                  range.collapse(false);
                  sel.removeAllRanges();
                  sel.addRange(range);
                }
              }
            }
          };
          
          return (
            <div className="relative w-full">
              <div 
                ref={editorRef} 
                contentEditable 
                onInput={handleInput}
                onKeyDown={handleKeyDown}
                data-cell-column={column}
                className="w-full min-h-[2.5rem] bg-transparent focus:bg-gray-50 focus:ring-1 focus:ring-blue-300 rounded px-2 py-1 cursor-text text-sm"
                style={{ wordWrap: 'break-word', whiteSpace: 'pre-wrap' }}
                suppressContentEditableWarning
              />
              {!value && (
                <div className="absolute top-1 left-2 text-gray-400 pointer-events-none select-none text-sm">
                  {placeholder}
                </div>
              )}
            </div>
          );
        }

        function CommentViewer() {
          const [expandedComments, setExpandedComments] = useState(new Set());
          const [collapsedColumns, setCollapsedColumns] = useState(new Set());
          const [comments, setComments] = useState([]);
          const [officeReady, setOfficeReady] = useState(false);
          const [loading, setLoading] = useState(true);
          const [showCreateDialog, setShowCreateDialog] = useState(false);
          const [newCommentId, setNewCommentId] = useState('');
          const [newCommentLocation, setNewCommentLocation] = useState('');
          const [columnWidths, setColumnWidths] = useState({
            admin: 300,
            proof: 300,
            galley: 300
          });
          const [selectedCommentId, setSelectedCommentId] = useState(null);
          const [lastSaveTime, setLastSaveTime] = useState(Date.now());
          const saveTimeoutRef = useRef(null);

          const applyFormat = (command) => {
            document.execCommand(command, false, null);
          };
          
          const applyHighlight = () => {
            document.execCommand('hiliteColor', false, 'yellow');
          };

          useEffect(() => {
            Office.onReady((info) => {
              if (info.host === Office.HostType.Word) {
                setOfficeReady(true);
                loadCommentsFromWord();
              }
            });
          }, []);

          // Auto-save whenever comments change (debounced)
          useEffect(() => {
            if (!officeReady || comments.length === 0) return;
            
            // Clear existing timeout
            if (saveTimeoutRef.current) {
              clearTimeout(saveTimeoutRef.current);
            }
            
            // Set new timeout - save 2 seconds after last change
            saveTimeoutRef.current = setTimeout(() => {
              saveCommentsToWordSilent();
            }, 2000);
            
            return () => {
              if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
              }
            };
          }, [comments, officeReady]);

          // Removed sync function - wasn't working reliably

          // Load comments FROM Word comment text (not document properties)
          async function loadCommentsFromWord() {
            setLoading(true);
            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  // Get all Word comments with their positions
                  const wordComments = context.document.body.getComments();
                  wordComments.load("items");
                  await context.sync();
                  
                  const commentData = [];
                  for (let i = 0; i < wordComments.items.length; i++) {
                    const comment = wordComments.items[i];
                    comment.load("content");
                    const range = comment.getRange();
                    range.load("start");
                    await context.sync();
                    
                    // Parse comment content
                    const content = comment.content;
                    
                    // Format: "125A|||{json data}" or just "125A" (for new comments)
                    let commentId, tableData;
                    if (content.includes('|||')) {
                      const parts = content.split('|||');
                      commentId = parts[0];
                      try {
                        tableData = JSON.parse(parts[1]);
                      } catch (e) {
                        console.error("Error parsing comment data:", e);
                        tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
                      }
                    } else {
                      // Just ID, no data yet
                      commentId = content;
                      tableData = { items: [{ id: "1", admin: "", proof: "", galley: "" }] };
                    }
                    
                    commentData.push({
                      id: commentId,
                      position: range.start,
                      location: `Position ${range.start}`,
                      timestamp: new Date().toISOString().split('T')[0],
                      items: tableData.items
                    });
                  }
                  
                  // Sort by position in document
                  commentData.sort((a, b) => a.position - b.position);
                  
                  setComments(commentData);
                  
                  if (commentData.length > 0) {
                    setExpandedComments(new Set([commentData[0].id]));
                  }
                });
              } catch (error) {
                console.error("Error loading comments:", error);
                alert("Error loading comments: " + error.message);
              } finally {
                setLoading(false);
              }
            }, 100);
          }

          // Save comments TO Word comment text (silent, no alert)
          function saveCommentsToWordSilent() {
            if (!officeReady) return;
            
            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  const wordComments = context.document.body.getComments();
                  wordComments.load("items");
                  await context.sync();
                  
                  // Update each Word comment with its data
                  for (let i = 0; i < wordComments.items.length; i++) {
                    const wordComment = wordComments.items[i];
                    wordComment.load("content");
                    await context.sync();
                    
                    // Find matching comment in our data
                    const currentContent = wordComment.content;
                    const commentId = currentContent.includes('|||') ? 
                      currentContent.split('|||')[0] : currentContent;
                    
                    const ourComment = comments.find(c => c.id === commentId);
                    
                    if (ourComment) {
                      // Encode as: ID|||{json}
                      const newContent = `${ourComment.id}|||${JSON.stringify({ items: ourComment.items })}`;
                      
                      // Only update if changed (to avoid unnecessary operations)
                      if (wordComment.content !== newContent) {
                        wordComment.content = newContent;
                      }
                    }
                  }
                  
                  await context.sync();
                  setLastSaveTime(Date.now());
                });
              } catch (error) {
                console.error("Error auto-saving:", error);
              }
            }, 100);
          }

          // Save comments to document properties (with alert)
          function saveCommentsToWord() {
            if (!officeReady) {
              alert("Please wait for Office to finish loading");
              return;
            }
            
            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  const properties = context.document.properties;
                  const customProps = properties.customProperties;
                  
                  const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
                  await context.sync();
                  
                  const commentsJson = JSON.stringify(comments);
                  
                  if (commentsProp.isNullObject) {
                    customProps.add("lawReviewComments", commentsJson);
                  } else {
                    commentsProp.value = commentsJson;
                  }
                  
                  await context.sync();
                  setLastSaveTime(Date.now());
                  alert("Comments saved successfully!");
                });
              } catch (error) {
                console.error("Error saving comments:", error);
                alert("Error saving comments: " + error.message);
              }
            }, 100);
          }

          // Create new comment using Word's native comment system
          function createNewCommentFromSelection() {
            if (!officeReady) {
              alert("Please wait for Office to finish loading");
              return;
            }
            
            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  const range = context.document.getSelection();
                  range.load("text");
                  await context.sync();
                  
                  if (range.text.length === 0) {
                    alert("Please select some text first!");
                    return;
                  }
                  
                  let locationText = range.text.substring(0, 50);
                  if (range.text.length > 50) {
                    locationText += "...";
                  }
                  
                  setNewCommentLocation(`Text: "${locationText}"`);
                  setShowCreateDialog(true);
                });
              } catch (error) {
                console.error("Error creating comment:", error);
                alert("Error creating comment: " + error.message);
              }
            }, 100);
          }

          // Finalize creating comment - adds Word comment + saves data
          function finalizeCreateComment() {
            if (!newCommentId.trim()) {
              alert("Please enter a comment ID!");
              return;
            }

            if (comments.some(c => c.id === newCommentId)) {
              alert("A comment with this ID already exists!");
              return;
            }

            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  // Create a native Word comment with just the ID
                  const range = context.document.getSelection();
                  const comment = range.insertComment(newCommentId);
                  await context.sync();
                  
                  // Create our structured data
                  const newComment = {
                    id: newCommentId,
                    location: newCommentLocation,
                    timestamp: new Date().toISOString().split('T')[0] + " " + 
                               new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
                    items: [{ id: "1", admin: "", proof: "", galley: "" }]
                  };
                  
                  const updatedComments = [...comments, newComment];
                  setComments(updatedComments);
                  
                  const newExpanded = new Set(expandedComments);
                  newExpanded.add(newCommentId);
                  setExpandedComments(newExpanded);
                  
                  // Save to document properties
                  const properties = context.document.properties;
                  const customProps = properties.customProperties;
                  const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
                  await context.sync();
                  
                  if (commentsProp.isNullObject) {
                    customProps.add("lawReviewComments", JSON.stringify(updatedComments));
                  } else {
                    commentsProp.value = JSON.stringify(updatedComments);
                  }
                  
                  await context.sync();
                  
                  setShowCreateDialog(false);
                  setNewCommentId('');
                  setNewCommentLocation('');
                  
                  alert("Comment created successfully! You'll see it in Word's margin.");
                });
              } catch (error) {
                console.error("Error finalizing comment:", error);
                alert("Error creating comment: " + error.message);
              }
            }, 100);
          }

          // Jump to comment by finding the Word comment with matching text
          function jumpToComment(commentId) {
            setTimeout(async () => {
              try {
                await Word.run(async (context) => {
                  const comments = context.document.body.getComments();
                  comments.load("items");
                  await context.sync();
                  
                  let found = false;
                  for (let i = 0; i < comments.items.length; i++) {
                    const comment = comments.items[i];
                    comment.load("content");
                    await context.sync();
                    
                    if (comment.content === commentId) {
                      const range = comment.getRange();
                      range.select();
                      found = true;
                      break;
                    }
                  }
                  
                  if (!found) {
                    alert("Could not find this comment in the document.");
                  }
                });
              } catch (error) {
                console.error("Error jumping to comment:", error);
                alert("Error navigating to comment: " + error.message);
              }
            }, 100);
          }

          // Removed deleteCommentById function - delete via Word instead!

          const allEditors = ['All', 'Admin', 'Proof', 'Galley'];

          const filteredComments = useMemo(() => {
            return comments; // Show all comments, no filtering
          }, [comments]);

          const toggleExpand = (commentId) => {
            const newExpanded = new Set(expandedComments);
            if (newExpanded.has(commentId)) {
              newExpanded.delete(commentId);
            } else {
              newExpanded.add(commentId);
            }
            setExpandedComments(newExpanded);
          };

          const toggleColumn = (columnName) => {
            const newCollapsed = new Set(collapsedColumns);
            if (newCollapsed.has(columnName)) {
              newCollapsed.delete(columnName);
            } else {
              newCollapsed.add(columnName);
            }
            setCollapsedColumns(newCollapsed);
          };

          const addRowAfter = (commentId, afterIndex) => {
            setComments(comments.map(comment => {
              if (comment.id === commentId) {
                const newItems = [...comment.items];
                newItems.splice(afterIndex + 1, 0, { id: "", admin: "", proof: "", galley: "" });
                return { ...comment, items: newItems };
              }
              return comment;
            }));
          };

          const updateCell = (commentId, itemIndex, column, value) => {
            setComments(comments.map(comment => {
              if (comment.id === commentId) {
                const newItems = [...comment.items];
                newItems[itemIndex] = { ...newItems[itemIndex], [column]: value };
                return { ...comment, items: newItems };
              }
              return comment;
            }));
          };

          const deleteRow = (commentId, itemIndex) => {
            setComments(comments.map(comment => {
              if (comment.id === commentId) {
                const newItems = comment.items.filter((_, idx) => idx !== itemIndex);
                return { ...comment, items: newItems };
              }
              return comment;
            }));
          };

          // Icons
          const SearchIcon = () => (
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path>
            </svg>
          );
          const ChevronDown = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          );
          const ChevronUp = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <polyline points="18 15 12 9 6 15"></polyline>
            </svg>
          );
          const Plus = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
              <line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          );

          return (
            <div className="h-screen flex flex-col bg-gray-50">
              {/* Header - Title on top, buttons below */}
              <div className="bg-stone-600 text-white p-2 shadow-lg">
                <h1 className="text-base font-bold mb-1 text-center tracking-wide">Law Review Comments v34</h1>
                <div className="flex items-center justify-between gap-2">
                  <div className="flex gap-1">
                    {/* Formatting Toolbar */}
                    <button onClick={() => applyFormat('bold')}
                      className="px-2 py-0.5 hover:bg-stone-700 rounded font-bold text-xs" title="Bold">B</button>
                    <button onClick={() => applyFormat('italic')}
                      className="px-2 py-0.5 hover:bg-stone-700 rounded italic text-xs" title="Italic">I</button>
                    <button onClick={applyHighlight}
                      className="px-2 py-0.5 hover:bg-stone-700 rounded text-xs" title="Highlight" style={{backgroundColor: 'rgba(255,255,0,0.3)'}}>H</button>
                    <button onClick={() => applyFormat('removeFormat')}
                      className="px-2 py-0.5 hover:bg-stone-700 rounded text-xs text-red-300" title="Clear">âœ•</button>
                  </div>
                  
                  <div className="flex gap-1">
                    <button onClick={createNewCommentFromSelection}
                      className="bg-emerald-600 hover:bg-emerald-700 px-2 py-0.5 rounded text-xs transition"
                      style={{ cursor: 'pointer' }}>+ New</button>
                    <button onClick={loadCommentsFromWord}
                      className="bg-cyan-600 hover:bg-cyan-700 px-2 py-0.5 rounded text-xs transition"
                      style={{ cursor: 'pointer' }}>ðŸ”„ Refresh</button>
                  </div>
                </div>
              </div>

              {/* Create Dialog */}
              {showCreateDialog && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                  <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
                    <h2 className="text-xl font-bold mb-4">Create New Comment</h2>
                    <div className="mb-4">
                      <label className="block text-sm font-medium text-gray-700 mb-2">
                        Comment ID (e.g., "125A")
                      </label>
                      <input type="text" value={newCommentId} onChange={(e) => setNewCommentId(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                        placeholder="125A" autoFocus />
                    </div>
                    <div className="mb-4">
                      <label className="block text-sm font-medium text-gray-700 mb-2">Location</label>
                      <input type="text" value={newCommentLocation} onChange={(e) => setNewCommentLocation(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500" />
                      <p className="mt-1 text-xs text-gray-500">
                        A Word comment with this ID will appear in the margin. To delete later, just delete the Word comment and click Refresh.
                      </p>
                    </div>
                    <div className="flex gap-2 justify-end">
                      <button onClick={() => { setShowCreateDialog(false); setNewCommentId(''); setNewCommentLocation(''); }}
                        className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 transition">Cancel</button>
                      <button onClick={finalizeCreateComment}
                        className="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition">Create Comment</button>
                    </div>
                  </div>
                </div>
              )}

              {/* Comments List - Compact */}
              <div className="flex-1 overflow-y-auto p-2">
                {loading ? (
                  <div className="text-center text-gray-500 mt-8">Loading comments...</div>
                ) : comments.length === 0 ? (
                  <div className="text-center text-gray-500 mt-8">
                    <p className="text-lg mb-2">No comments yet!</p>
                    <p className="text-sm">Select some text and click "New Comment" to get started.</p>
                    <p className="text-xs mt-2 text-gray-400">Tip: Delete comments by right-clicking the Word comment in the margin, then click Refresh here.</p>
                  </div>
                ) : filteredComments.length === 0 ? (
                  <div className="text-center text-gray-500 mt-8">No comments found.</div>
                ) : (
                  filteredComments.map(comment => (
                    <div 
                      key={comment.id} 
                      id={`comment-${comment.id}`}
                      className="mb-2 bg-white rounded shadow border border-gray-200"
                    >
                      {/* Comment Header - Compact */}
                      <div className="p-2 bg-gray-100 border-b border-gray-200 flex items-center justify-between gap-2">
                        <div className="flex items-center gap-2 flex-1 cursor-pointer hover:bg-gray-200 p-1 rounded-l transition"
                          onClick={() => toggleExpand(comment.id)}>
                          {expandedComments.has(comment.id) ? <ChevronUp /> : <ChevronDown />}
                          <div className="text-sm">
                            <span 
                              className="font-bold text-blue-600 cursor-pointer hover:underline"
                              onClick={(e) => {
                                e.stopPropagation();
                                jumpToComment(comment.id);
                              }}
                            >
                              {comment.id}
                            </span>
                            <span className="mx-1 text-gray-400">|</span>
                            <span className="text-gray-700 text-xs">{comment.location}</span>
                          </div>
                        </div>
                        <div className="flex items-center gap-2 shrink-0">
                          <span className="text-xs text-gray-500">
                            {comment.items.length} item{comment.items.length !== 1 ? 's' : ''}
                          </span>
                        </div>
                      </div>

                      {/* Expanded Table */}
                      {expandedComments.has(comment.id) && (
                        <div className="overflow-x-auto">
                          <table className="w-full border-collapse">
                            <thead className="bg-gray-50 border-b-2 border-gray-300">
                              <tr>
                                <th className="px-3 py-2 text-left text-xs font-semibold text-gray-700 border-r border-gray-300 w-24">Item #</th>
                                {[
                                  { key: 'admin', label: 'Admin' },
                                  { key: 'proof', label: 'Proof' },
                                  { key: 'galley', label: 'Galley' }
                                ].map(({ key, label }) => (
                                  !collapsedColumns.has(key) && (
                                    <th key={key}
                                      className="px-3 py-2 text-left text-xs font-semibold text-gray-700 border-r border-gray-300 cursor-pointer hover:bg-gray-100 transition group"
                                      style={{ minWidth: '300px' }} onClick={(e) => { e.stopPropagation(); toggleColumn(key); }}>
                                      <div className="flex items-center justify-between">
                                        <span>{label}</span><ChevronUp />
                                      </div>
                                    </th>
                                  )
                                ))}
                                {collapsedColumns.size > 0 && (
                                  <th className="px-1 py-1 text-center text-xs font-semibold text-gray-500 border-r border-gray-300">
                                    <div className="flex flex-col gap-1">
                                      {Array.from(collapsedColumns).map(col => (
                                        <button key={col} onClick={(e) => { e.stopPropagation(); toggleColumn(col); }}
                                          className="px-1 py-0.5 bg-gray-200 hover:bg-gray-300 rounded text-xs flex items-center gap-1 transition">
                                          <ChevronDown /> {col.charAt(0).toUpperCase() + col.slice(1)}
                                        </button>
                                      ))}
                                    </div>
                                  </th>
                                )}
                                <th className="px-1 py-1 w-8"></th>
                              </tr>
                            </thead>
                            <tbody>
                              {comment.items.map((item, idx) => (
                                <tr key={idx} className={idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                                  <td className="px-2 py-1 text-xs font-bold text-blue-700 border-r border-gray-200 align-top">
                                    <input type="text" value={item.id} onChange={(e) => updateCell(comment.id, idx, 'id', e.target.value)}
                                      className="w-full bg-transparent border-none focus:outline-none focus:ring-1 focus:ring-blue-300 rounded px-1 text-xs"
                                      placeholder="ID" />
                                  </td>
                                  {!collapsedColumns.has('admin') && (
                                    <td className="px-2 py-1 text-gray-800 border-r border-gray-200 align-top">
                                      <RichTextCell value={item.admin} onChange={(html) => updateCell(comment.id, idx, 'admin', html)} 
                                        placeholder="â€”" commentId={comment.id} itemIndex={idx} column="admin" />
                                    </td>
                                  )}
                                  {!collapsedColumns.has('proof') && (
                                    <td className="px-2 py-1 text-gray-800 border-r border-gray-200 align-top">
                                      <RichTextCell value={item.proof} onChange={(html) => updateCell(comment.id, idx, 'proof', html)} 
                                        placeholder="â€”" commentId={comment.id} itemIndex={idx} column="proof" />
                                    </td>
                                  )}
                                  {!collapsedColumns.has('galley') && (
                                    <td className="px-2 py-1 text-gray-800 border-r border-gray-200 align-top">
                                      <RichTextCell value={item.galley} onChange={(html) => updateCell(comment.id, idx, 'galley', html)} 
                                        placeholder="â€”" commentId={comment.id} itemIndex={idx} column="galley" />
                                    </td>
                                  )}
                                  {collapsedColumns.size > 0 && <td className="border-r border-gray-200"></td>}
                                  <td className="px-1 py-1 text-center align-top">
                                    <div className="flex flex-col gap-0.5">
                                      <button type="button" onClick={() => addRowAfter(comment.id, idx)}
                                        className="text-blue-600 hover:text-blue-800 hover:bg-stone-50 p-0.5 rounded transition text-xs" title="Add row below">
                                        +
                                      </button>
                                      <button type="button" onClick={() => deleteRow(comment.id, idx)}
                                        className="text-red-600 hover:text-red-800 hover:bg-red-50 p-0.5 rounded transition text-xs font-bold" title="Delete row">
                                        Ã—
                                      </button>
                                    </div>
                                  </td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      )}
                    </div>
                  ))
                )}
              </div>

              {/* Footer - Compact */}
              <div className="bg-gray-100 border-t border-gray-300 px-2 py-1 text-xs text-gray-600">
                {officeReady ? "âœ“ Ready" : "âš  Loading..."} â€¢ 
                {filteredComments.length} comment{filteredComments.length !== 1 ? 's' : ''} â€¢ 
                Data stored in Word comments â€¢ Copy/paste works!
              </div>
            </div>
          );
        }

        ReactDOM.render(<CommentViewer />, document.getElementById('root'));
    </script>
</body>
</html>
