<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Law Review Comment Viewer - v38</title>

<script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
body { 
  margin: 0; 
  padding: 0; 
  font-family: Helvetica, Arial, sans-serif;
  background: #f8f9fa;
}
[contenteditable] { outline: none; }
[contenteditable]:focus { background-color: #f0f0f0; }

::-webkit-scrollbar {
  width: 8px;
}
::-webkit-scrollbar-track {
  background: #f1f1f1;
}
::-webkit-scrollbar-thumb {
  background: #6b7280;
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #4b5563;
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
console.log("Law Review Add-in Version 38 - Green cell marking!");

const { useState, useEffect, useMemo, useRef } = React;

function RichTextCell({ value, onChange, placeholder, commentId, itemIndex, column }) {
  const editorRef = useRef(null);
  const isUpdatingRef = useRef(false);

  useEffect(() => {
    if (editorRef.current && !editorRef.current.innerHTML) {
      editorRef.current.innerHTML = value || '';
    }
  }, []);

  useEffect(() => {
    if (editorRef.current && !isUpdatingRef.current && document.activeElement !== editorRef.current) {
      const currentHtml = editorRef.current.innerHTML;
      if (currentHtml !== value && value !== undefined) {
        editorRef.current.innerHTML = value || '';
      }
    }
  }, [value]);

  const handleInput = (e) => {
    isUpdatingRef.current = true;
    const newHtml = e.target.innerHTML;
    onChange(newHtml);
    setTimeout(() => {
      isUpdatingRef.current = false;
    }, 0);
  };

  const handlePaste = (e) => {
    e.preventDefault();
    
    const html = e.clipboardData.getData('text/html');
    
    if (html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      
      const processNode = (node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          return document.createTextNode(node.textContent);
        }
        
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName.toLowerCase();
          const style = node.style;
          const isBold = tagName === 'b' || tagName === 'strong' || 
                        style.fontWeight === 'bold' || style.fontWeight === '700' ||
                        node.getAttribute('style')?.includes('font-weight: bold');
          const isItalic = tagName === 'i' || tagName === 'em' || 
                          style.fontStyle === 'italic' || 
                          node.getAttribute('style')?.includes('font-style: italic');
          
          const children = Array.from(node.childNodes).map(processNode);
          
          if (isBold && isItalic) {
            const strong = document.createElement('strong');
            const em = document.createElement('em');
            children.forEach(child => em.appendChild(child));
            strong.appendChild(em);
            return strong;
          } else if (isBold) {
            const strong = document.createElement('strong');
            children.forEach(child => strong.appendChild(child));
            return strong;
          } else if (isItalic) {
            const em = document.createElement('em');
            children.forEach(child => em.appendChild(child));
            return em;
          } else {
            const fragment = document.createDocumentFragment();
            children.forEach(child => fragment.appendChild(child));
            return fragment;
          }
        }
        
        return document.createTextNode('');
      };
      
      const processed = document.createDocumentFragment();
      Array.from(temp.childNodes).forEach(node => {
        processed.appendChild(processNode(node));
      });
      
      const selection = window.getSelection();
      if (selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        range.deleteContents();
        range.insertNode(processed);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    } else {
      const text = e.clipboardData.getData('text/plain');
      document.execCommand('insertText', false, text);
    }
  };

  const handleCopy = (e) => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = document.createElement('div');
      container.appendChild(range.cloneContents());
      
      const elementsWithBg = container.querySelectorAll('[style*="background"]');
      elementsWithBg.forEach(el => {
        el.style.backgroundColor = '';
        el.style.background = '';
      });
      
      e.clipboardData.setData('text/plain', container.textContent);
      e.clipboardData.setData('text/html', container.innerHTML);
      e.preventDefault();
    }
  };

  const handleKeyDown = (e) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'b') {
      e.preventDefault();
      document.execCommand('bold', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'i') {
      e.preventDefault();
      document.execCommand('italic', false, null);
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key === 'u') {
      e.preventDefault();
      document.execCommand('underline', false, null);
      return;
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      const allCells = Array.from(document.querySelectorAll(`[data-cell-column="${column}"]`));
      const currentIndex = allCells.indexOf(editorRef.current);
      if (currentIndex >= 0 && currentIndex < allCells.length - 1) {
        const nextCell = allCells[currentIndex + 1];
        nextCell.focus();
        const range = document.createRange();
        const sel = window.getSelection();
        if (nextCell.childNodes.length > 0) {
          range.selectNodeContents(nextCell);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
    }
  };

  return (
    <div className="relative w-full" style={{ paddingRight: '28px' }}>
      <div
        ref={editorRef}
        contentEditable
        onInput={handleInput}
        onPaste={handlePaste}
        onCopy={handleCopy}
        onKeyDown={handleKeyDown}
        data-cell-column={column}
        className="w-full min-h-[1.8rem] bg-transparent focus:bg-gray-100 focus:ring-1 focus:ring-gray-400 rounded px-2 py-1 cursor-text text-sm leading-tight"
        style={{ 
          wordWrap: 'break-word', 
          whiteSpace: 'pre-wrap',
          fontFamily: 'Helvetica, Arial, sans-serif'
        }}
        suppressContentEditableWarning
      />
      {!value && (
        <div className="absolute top-1 left-2 text-gray-400 pointer-events-none select-none text-sm italic">
          {placeholder}
        </div>
      )}
    </div>
  );
}

function CommentViewer() {
  const [expandedComments, setExpandedComments] = useState(new Set());
  const [collapsedColumns, setCollapsedColumns] = useState(new Set());
  const [comments, setComments] = useState([]);
  const [officeReady, setOfficeReady] = useState(false);
  const [loading, setLoading] = useState(true);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCommentId, setNewCommentId] = useState('');
  const [newCommentLocation, setNewCommentLocation] = useState('');
  const [lastSaveTime, setLastSaveTime] = useState(Date.now());
  const saveTimeoutRef = useRef(null);
  const commentIdInputRef = useRef(null);
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [currentUsername, setCurrentUsername] = useState(null);
  const [showUsernameDialog, setShowUsernameDialog] = useState(false);
  const [tempUsername, setTempUsername] = useState('');
  const pendingEditRef = useRef(null);
  const [searchQuery, setSearchQuery] = useState('');

  const applyFormat = (command) => {
    document.execCommand(command, false, null);
  };

  const toggleHighlight = () => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const parent = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
      
      if (parent && parent.style.backgroundColor === 'yellow') {
        document.execCommand('hiliteColor', false, 'transparent');
      } else {
        document.execCommand('hiliteColor', false, 'yellow');
      }
    }
  };

  const toggleRed = () => {
    const selection = window.getSelection();
    if (selection.rangeCount > 0 && !selection.isCollapsed) {
      const range = selection.getRangeAt(0);
      const span = document.createElement('span');
      const fragment = range.cloneContents();
      span.appendChild(fragment);
      
      const hasRed = span.querySelector('[style*="color: red"]') || 
                     span.querySelector('font[color="red"]') ||
                     (span.firstElementChild && window.getComputedStyle(span.firstElementChild).color === 'rgb(255, 0, 0)');
      
      if (hasRed) {
        document.execCommand('foreColor', false, 'black');
        document.execCommand('removeFormat', false, null);
      } else {
        document.execCommand('foreColor', false, 'red');
      }
    }
  };

  const toggleCellImplemented = (commentId, itemIndex, column) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        const item = newItems[itemIndex];
        const implKey = `_${column}Implemented`;
        newItems[itemIndex] = { ...item, [implKey]: !item[implKey] };
        return { ...comment, items: newItems };
      }
      return comment;
    });
    setComments(newComments);
  };

  const saveToHistory = (newComments) => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(JSON.parse(JSON.stringify(newComments)));
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const previousState = history[historyIndex - 1];
      setComments(JSON.parse(JSON.stringify(previousState)));
      setHistoryIndex(historyIndex - 1);
    }
  };

  useEffect(() => {
    Office.onReady((info) => {
      if (info.host === Office.HostType.Word) {
        setOfficeReady(true);
        loadCommentsFromWord();
      }
    });
  }, []);

  useEffect(() => {
    if (!officeReady || comments.length === 0) return;
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      saveCommentsToWordSilent();
    }, 2000);
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [comments, officeReady]);

  async function loadCommentsFromWord() {
    setLoading(true);
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          const commentData = [];
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            const range = comment.getRange();
            range.load("start");
            await context.sync();

            const content = comment.content;
            let commentId, tableData;
            if (content.includes('|||')) {
              const parts = content.split('|||');
              commentId = parts[0];
              try {
                tableData = JSON.parse(parts[1]);
              } catch (e) {
                console.error("Error parsing comment data:", e);
                tableData = { items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false, _adminEditor: "", _proofEditor: "", _galleyEditor: "", _adminImplemented: false, _proofImplemented: false, _galleyImplemented: false }] };
              }
            } else {
              commentId = content;
              tableData = { items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false, _adminEditor: "", _proofEditor: "", _galleyEditor: "", _adminImplemented: false, _proofImplemented: false, _galleyImplemented: false }] };
            }

            commentData.push({
              id: commentId,
              position: range.start,
              location: `Position ${range.start}`,
              timestamp: new Date().toISOString().split('T')[0],
              items: tableData.items
            });
          }

          commentData.sort((a, b) => a.position - b.position);
          setComments(commentData);

          if (commentData.length > 0) {
            setExpandedComments(new Set([commentData[0].id]));
          }
        });
      } catch (error) {
        console.error("Error loading comments:", error);
        alert("Error loading comments: " + error.message);
      } finally {
        setLoading(false);
      }
    }, 100);
  }

  function saveCommentsToWordSilent() {
    if (!officeReady) return;
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          for (let i = 0; i < wordComments.items.length; i++) {
            const wordComment = wordComments.items[i];
            wordComment.load("content");
            await context.sync();

            const currentContent = wordComment.content;
            const commentId = currentContent.includes('|||') ? currentContent.split('|||')[0] : currentContent;
            const ourComment = comments.find(c => c.id === commentId);

            if (ourComment) {
              const newContent = `${ourComment.id}|||${JSON.stringify({ items: ourComment.items })}`;
              if (wordComment.content !== newContent) {
                wordComment.content = newContent;
              }
            }
          }

          await context.sync();
          setLastSaveTime(Date.now());
        });
      } catch (error) {
        console.error("Error auto-saving:", error);
      }
    }, 100);
  }

  function createNewCommentFromSelection() {
    if (!officeReady) {
      alert("Please wait for Office to finish loading");
      return;
    }
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          range.load("text");
          await context.sync();

          if (range.text.length === 0) {
            alert("Please select some text first!");
            return;
          }

          let locationText = range.text.substring(0, 50);
          if (range.text.length > 50) {
            locationText += "...";
          }

          setNewCommentLocation(`Text: "${locationText}"`);
          setShowCreateDialog(true);
        });
      } catch (error) {
        console.error("Error creating comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function finalizeCreateComment() {
    if (!newCommentId.trim()) {
      alert("Please enter a comment ID!");
      return;
    }
    if (comments.some(c => c.id === newCommentId)) {
      alert("A comment with this ID already exists!");
      return;
    }

    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const range = context.document.getSelection();
          const comment = range.insertComment(newCommentId);
          await context.sync();

          const newComment = {
            id: newCommentId,
            location: newCommentLocation,
            timestamp: new Date().toISOString().split('T')[0] + " " + new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
            items: [{ id: "1", admin: "", proof: "", galley: "", isHeading: false, _adminEditor: "", _proofEditor: "", _galleyEditor: "", _adminImplemented: false, _proofImplemented: false, _galleyImplemented: false }]
          };

          const updatedComments = [...comments, newComment];
          setComments(updatedComments);

          const newExpanded = new Set(expandedComments);
          newExpanded.add(newCommentId);
          setExpandedComments(newExpanded);

          const properties = context.document.properties;
          const customProps = properties.customProperties;
          const commentsProp = customProps.getItemOrNullObject("lawReviewComments");
          await context.sync();

          if (commentsProp.isNullObject) {
            customProps.add("lawReviewComments", JSON.stringify(updatedComments));
          } else {
            commentsProp.value = JSON.stringify(updatedComments);
          }

          await context.sync();

          setShowCreateDialog(false);
          setNewCommentId('');
          setNewCommentLocation('');

          alert("Comment created successfully! You'll see it in Word's margin.");
        });
      } catch (error) {
        console.error("Error finalizing comment:", error);
        alert("Error creating comment: " + error.message);
      }
    }, 100);
  }

  function jumpToComment(commentId) {
    setTimeout(async () => {
      try {
        await Word.run(async (context) => {
          const wordComments = context.document.body.getComments();
          wordComments.load("items");
          await context.sync();

          let found = false;
          for (let i = 0; i < wordComments.items.length; i++) {
            const comment = wordComments.items[i];
            comment.load("content");
            await context.sync();

            const content = comment.content;
            const actualCommentId = content.includes('|||') ? content.split('|||')[0] : content;

            if (actualCommentId === commentId) {
              const range = comment.getRange();
              range.select();
              found = true;
              break;
            }
          }

          if (!found) {
            alert("Could not find this comment in the document.");
          }
        });
      } catch (error) {
        console.error("Error jumping to comment:", error);
        alert("Error navigating to comment: " + error.message);
      }
    }, 100);
  }

  const filteredComments = useMemo(() => {
    if (!searchQuery.trim()) return comments;
    
    const query = searchQuery.toLowerCase();
    return comments.filter(comment => {
      if (comment.id.toLowerCase().includes(query)) return true;
      if (comment.location.toLowerCase().includes(query)) return true;
      
      return comment.items.some(item => {
        return (
          item.id?.toLowerCase().includes(query) ||
          item.admin?.toLowerCase().includes(query) ||
          item.proof?.toLowerCase().includes(query) ||
          item.galley?.toLowerCase().includes(query)
        );
      });
    });
  }, [comments, searchQuery]);

  const toggleExpand = (commentId) => {
    const newExpanded = new Set(expandedComments);
    if (newExpanded.has(commentId)) {
      newExpanded.delete(commentId);
    } else {
      newExpanded.add(commentId);
    }
    setExpandedComments(newExpanded);
  };

  const toggleColumn = (columnName) => {
    const newCollapsed = new Set(collapsedColumns);
    if (newCollapsed.has(columnName)) {
      newCollapsed.delete(columnName);
    } else {
      newCollapsed.add(columnName);
    }
    setCollapsedColumns(newCollapsed);
  };

  const addRowAfter = (commentId, afterIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems.splice(afterIndex + 1, 0, { id: "", admin: "", proof: "", galley: "", isHeading: false, _adminEditor: "", _proofEditor: "", _galleyEditor: "", _adminImplemented: false, _proofImplemented: false, _galleyImplemented: false });
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const toggleHeading = (commentId, itemIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        newItems[itemIndex] = { ...newItems[itemIndex], isHeading: !newItems[itemIndex].isHeading };
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const updateCell = (commentId, itemIndex, column, value) => {
    if (!currentUsername && column !== 'id' && column !== 'isHeading' && value && value.trim()) {
      pendingEditRef.current = { commentId, itemIndex, column, value };
      setShowUsernameDialog(true);
      return;
    }

    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = [...comment.items];
        const updatedItem = { ...newItems[itemIndex], [column]: value };
        
        if (currentUsername && column !== 'id' && column !== 'isHeading' && !column.startsWith('_')) {
          const editorKey = `_${column}Editor`;
          updatedItem[editorKey] = currentUsername;
        }
        
        newItems[itemIndex] = updatedItem;
        return { ...comment, items: newItems };
      }
      return comment;
    });
    setComments(newComments);
  };

  const confirmUsername = () => {
    if (tempUsername.trim()) {
      setCurrentUsername(tempUsername.trim());
      setShowUsernameDialog(false);
      
      if (pendingEditRef.current) {
        const { commentId, itemIndex, column, value } = pendingEditRef.current;
        const newComments = comments.map(comment => {
          if (comment.id === commentId) {
            const newItems = [...comment.items];
            const updatedItem = { ...newItems[itemIndex], [column]: value };
            const editorKey = `_${column}Editor`;
            updatedItem[editorKey] = tempUsername.trim();
            newItems[itemIndex] = updatedItem;
            return { ...comment, items: newItems };
          }
          return comment;
        });
        setComments(newComments);
        pendingEditRef.current = null;
      }
    }
  };

  const deleteRow = (commentId, itemIndex) => {
    const newComments = comments.map(comment => {
      if (comment.id === commentId) {
        const newItems = comment.items.filter((_, idx) => idx !== itemIndex);
        return { ...comment, items: newItems };
      }
      return comment;
    });
    saveToHistory(newComments);
    setComments(newComments);
  };

  const handleDialogKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      finalizeCreateComment();
    }
  };

  useEffect(() => {
    if (showCreateDialog && commentIdInputRef.current) {
      commentIdInputRef.current.focus();
    }
  }, [showCreateDialog]);

  const ChevronDown = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  );
  const ChevronUp = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  );

  return (
    <div className="h-screen flex flex-col bg-gray-50">
      <div className="bg-gray-600 border-b border-gray-700 px-3 py-1.5">
        <div className="flex items-center justify-between gap-2 mb-1.5">
          <h1 className="text-sm font-semibold text-white">Law Review Comments</h1>
          <div className="flex gap-1">
            <button onClick={createNewCommentFromSelection}
              className="bg-green-600 hover:bg-green-700 text-white px-2 py-0.5 rounded text-xs font-medium"
              style={{ cursor: 'pointer' }}>+ New</button>
            <button onClick={loadCommentsFromWord}
              className="bg-sky-500 hover:bg-sky-600 text-white px-2 py-0.5 rounded text-xs font-medium"
              style={{ cursor: 'pointer' }}>â†» Refresh</button>
            <button onClick={undo}
              disabled={historyIndex <= 0}
              className={`${historyIndex <= 0 ? 'bg-gray-400 cursor-not-allowed' : 'bg-amber-500 hover:bg-amber-600'} text-white px-2 py-0.5 rounded text-xs font-medium`}
              style={{ cursor: historyIndex <= 0 ? 'not-allowed' : 'pointer' }}
              title="Undo">âŽŒ Undo</button>
          </div>
        </div>
        <div className="flex gap-1">
          <button onClick={() => applyFormat('bold')}
            className="px-2 py-0.5 bg-gray-700 hover:bg-gray-800 border border-gray-600 rounded font-bold text-white text-xs"
            title="Bold">B</button>
          <button onClick={() => applyFormat('italic')}
            className="px-2 py-0.5 bg-gray-700 hover:bg-gray-800 border border-gray-600 rounded italic text-white text-xs"
            title="Italic">I</button>
          <button onClick={toggleHighlight}
            className="px-2 py-0.5 bg-yellow-400 hover:bg-yellow-500 border border-yellow-500 rounded text-gray-900 text-xs font-medium"
            title="Toggle Highlight">H</button>
          <button onClick={toggleRed}
            className="px-2 py-0.5 bg-red-500 hover:bg-red-600 border border-red-600 rounded text-white text-xs font-medium"
            title="Toggle Red Text">R</button>
          <button onClick={() => applyFormat('removeFormat')}
            className="px-2 py-0.5 bg-gray-700 hover:bg-gray-800 border border-gray-600 rounded text-red-400 text-xs"
            title="Clear">âœ•</button>
        </div>
        <div className="mt-1.5">
          <input 
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Search comments..."
            className="w-full px-2 py-1 text-xs border border-gray-500 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-gray-400"
          />
        </div>
      </div>

      {showUsernameDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-sm w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Enter Your Name</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Your name will appear on cells you edit
              </label>
              <input 
                type="text" 
                value={tempUsername} 
                onChange={(e) => setTempUsername(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    confirmUsername();
                  }
                }}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
                placeholder="Your name" 
                autoFocus
              />
            </div>
            <div className="flex gap-2 justify-end">
              <button 
                onClick={() => { setShowUsernameDialog(false); pendingEditRef.current = null; setTempUsername(''); }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm">
                Cancel
              </button>
              <button 
                onClick={confirmUsername}
                className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 text-sm font-medium">
                Confirm
              </button>
            </div>
          </div>
        </div>
      )}

      {showCreateDialog && (
        <div className="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl border border-gray-200">
            <h2 className="text-lg font-semibold mb-4 text-gray-800">Create New Comment</h2>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Comment ID (e.g., "125A")
              </label>
              <input 
                ref={commentIdInputRef}
                type="text" 
                value={newCommentId} 
                onChange={(e) => setNewCommentId(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent"
                placeholder="125A" 
              />
            </div>
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-1">Location</label>
              <input 
                type="text" 
                value={newCommentLocation} 
                onChange={(e) => setNewCommentLocation(e.target.value)}
                onKeyDown={handleDialogKeyDown}
                className="w-full px-3 py-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-gray-500 focus:border-transparent" 
              />
              <p className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                ðŸ’¡ A Word comment will appear in the margin. To delete later, just delete the Word comment and click Refresh.
              </p>
            </div>
            <div className="flex gap-2 justify-end">
              <button 
                onClick={() => { setShowCreateDialog(false); setNewCommentId(''); setNewCommentLocation(''); }}
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 text-sm">
                Cancel
              </button>
              <button 
                onClick={finalizeCreateComment}
                className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm font-medium">
                Create Comment
              </button>
            </div>
          </div>
        </div>
      )}

      <div className="flex-1 overflow-y-auto p-2">
        {loading ? (
          <div className="text-center text-gray-500 mt-8">
            <div className="inline-block animate-spin rounded-full h-8 w-8 border-2 border-gray-300 border-t-gray-600 mb-2"></div>
            <p className="text-sm">Loading comments...</p>
          </div>
        ) : comments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8 bg-white p-6 rounded border border-gray-200 max-w-sm mx-auto">
            <p className="text-base mb-2">ðŸ“‹ No comments yet</p>
            <p className="text-xs mb-1">Select some text and click "New Comment" to get started.</p>
            <p className="text-xs mt-3 text-gray-400">ðŸ’¡ Tip: Delete comments by right-clicking the Word comment in the margin, then click Refresh here.</p>
          </div>
        ) : filteredComments.length === 0 ? (
          <div className="text-center text-gray-500 mt-8">No comments found.</div>
        ) : (
          filteredComments.map(comment => (
            <div
              key={comment.id}
              id={`comment-${comment.id}`}
              className="mb-2 bg-white rounded border border-gray-200 shadow-sm"
            >
              <div className="px-2 py-1 bg-gray-50 border-b border-gray-200 flex items-center justify-between gap-2">
                <div className="flex items-center gap-2 flex-1 cursor-pointer hover:bg-gray-100 px-1 py-0.5 rounded"
                  onClick={() => toggleExpand(comment.id)}>
                  {expandedComments.has(comment.id) ? <ChevronUp /> : <ChevronDown />}
                  <div className="text-xs">
                    <span
                      className="font-semibold text-gray-700 cursor-pointer hover:underline"
                      onClick={(e) => {
                        e.stopPropagation();
                        jumpToComment(comment.id);
                      }}
                    >
                      {comment.id}
                    </span>
                    <span className="mx-1 text-gray-400">â€¢</span>
                    <span className="text-gray-600">{comment.location}</span>
                  </div>
                </div>
                <div className="flex items-center gap-2 shrink-0">
                  <span className="text-xs text-gray-500 bg-white px-2 py-0.5 rounded border border-gray-200">
                    {comment.items.length} item{comment.items.length !== 1 ? 's' : ''}
                  </span>
                </div>
              </div>

              {expandedComments.has(comment.id) && (
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse text-xs">
                    <thead className="bg-gray-100 border-b border-gray-300">
                      <tr>
                        <th className="px-2 py-1 text-left font-semibold text-gray-700 border-r border-gray-200" style={{ minWidth: '50px', width: '50px' }}>#</th>
                        {[
                          { key: 'admin', label: 'Admin' },
                          { key: 'proof', label: 'Proof' },
                          { key: 'galley', label: 'Galley' }
                        ].map(({ key, label }) => (
                          !collapsedColumns.has(key) && (
                            <th key={key}
                              className="px-2 py-1 text-left font-semibold text-gray-700 border-r border-gray-200 cursor-pointer hover:bg-gray-200"
                              style={{ minWidth: '250px' }} 
                              onClick={(e) => { e.stopPropagation(); toggleColumn(key); }}>
                              <div className="flex items-center justify-between">
                                <div>
                                  <div>{label}</div>
                                  {(() => {
                                    const editorKey = `_${key}Editor`;
                                    const editors = comment.items
                                      .map(item => item[editorKey])
                                      .filter(Boolean);
                                    const lastEditor = editors[editors.length - 1];
                                    return lastEditor ? (
                                      <div className="text-xs font-normal text-gray-500 italic">
                                        {lastEditor}
                                      </div>
                                    ) : null;
                                  })()}
                                </div>
                                <ChevronUp />
                              </div>
                            </th>
                          )
                        ))}
                        {collapsedColumns.size > 0 && (
                          <th className="px-1 py-1 text-center font-semibold text-gray-500 border-r border-gray-200">
                            <div className="flex flex-col gap-0.5">
                              {Array.from(collapsedColumns).map(col => (
                                <button key={col} onClick={(e) => { e.stopPropagation(); toggleColumn(col); }}
                                  className="px-1.5 py-0.5 bg-gray-200 hover:bg-gray-300 rounded text-xs flex items-center gap-1">
                                  <ChevronDown /> {col.charAt(0).toUpperCase() + col.slice(1)}
                                </button>
                              ))}
                            </div>
                          </th>
                        )}
                        <th className="px-1 py-1 w-8"></th>
                      </tr>
                    </thead>
                    <tbody>
                      {comment.items.map((item, idx) => (
                        <tr key={idx} className={item.isHeading ? 'bg-blue-50' : (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50')}>
                          <td className="px-1.5 py-0 font-semibold text-gray-700 border-r border-gray-200 align-top" style={{ minWidth: '50px', width: '50px' }}>
                            <input type="text" value={item.id} onChange={(e) => updateCell(comment.id, idx, 'id', e.target.value)}
                              className={`w-full bg-transparent border-none focus:outline-none focus:ring-1 focus:ring-gray-500 rounded px-1 py-1 text-xs ${item.isHeading ? 'font-bold' : ''}`}
                              placeholder="#" />
                          </td>
                          {!collapsedColumns.has('admin') && (
                            <td className={`px-1.5 py-0 text-gray-800 border-r border-gray-200 align-top relative ${item._adminImplemented ? 'bg-green-100' : ''}`}>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  toggleCellImplemented(comment.id, idx, 'admin');
                                }}
                                className={`absolute top-0 right-0 w-6 h-6 flex items-center justify-center rounded text-xs ${item._adminImplemented ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-400 hover:bg-gray-300'}`}
                                style={{ zIndex: 20, pointerEvents: 'auto', cursor: 'pointer' }}
                                title={item._adminImplemented ? "Mark as not implemented" : "Mark as implemented"}
                              >
                                âœ“
                              </button>
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.admin} onChange={(html) => updateCell(comment.id, idx, 'admin', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="admin" />
                              </div>
                            </td>
                          )}
                          {!collapsedColumns.has('proof') && (
                            <td className={`px-1.5 py-0 text-gray-800 border-r border-gray-200 align-top relative ${item._proofImplemented ? 'bg-green-100' : ''}`}>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  toggleCellImplemented(comment.id, idx, 'proof');
                                }}
                                className={`absolute top-0 right-0 w-6 h-6 flex items-center justify-center rounded text-xs ${item._proofImplemented ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-400 hover:bg-gray-300'}`}
                                style={{ zIndex: 20, pointerEvents: 'auto', cursor: 'pointer' }}
                                title={item._proofImplemented ? "Mark as not implemented" : "Mark as implemented"}
                              >
                                âœ“
                              </button>
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.proof} onChange={(html) => updateCell(comment.id, idx, 'proof', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="proof" />
                              </div>
                            </td>
                          )}
                          {!collapsedColumns.has('galley') && (
                            <td className={`px-1.5 py-0 text-gray-800 border-r border-gray-200 align-top relative ${item._galleyImplemented ? 'bg-green-100' : ''}`}>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  toggleCellImplemented(comment.id, idx, 'galley');
                                }}
                                className={`absolute top-0 right-0 w-6 h-6 flex items-center justify-center rounded text-xs ${item._galleyImplemented ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-400 hover:bg-gray-300'}`}
                                style={{ zIndex: 20, pointerEvents: 'auto', cursor: 'pointer' }}
                                title={item._galleyImplemented ? "Mark as not implemented" : "Mark as implemented"}
                              >
                                âœ“
                              </button>
                              <div className={item.isHeading ? 'font-semibold' : ''}>
                                <RichTextCell value={item.galley} onChange={(html) => updateCell(comment.id, idx, 'galley', html)} 
                                  placeholder="â€”" commentId={comment.id} itemIndex={idx} column="galley" />
                              </div>
                            </td>
                          )}
                          {collapsedColumns.size > 0 && <td className="border-r border-gray-200"></td>}
                          <td className="px-0.5 py-0 text-center align-top">
                            <div className="flex flex-col gap-0.5 py-1">
                              <button type="button" onClick={() => toggleHeading(comment.id, idx)}
                                className={`${item.isHeading ? 'text-blue-600' : 'text-gray-500'} hover:text-blue-800 hover:bg-blue-50 p-0.5 rounded text-xs font-bold`} 
                                title={item.isHeading ? "Convert to regular row" : "Convert to heading"}>
                                H
                              </button>
                              <button type="button" onClick={() => addRowAfter(comment.id, idx)}
                                className="text-blue-600 hover:text-blue-800 hover:bg-blue-50 p-0.5 rounded text-xs" title="Add row below">
                                +
                              </button>
                              <button type="button" onClick={() => deleteRow(comment.id, idx)}
                                className="text-red-600 hover:text-red-800 hover:bg-red-50 p-0.5 rounded text-xs font-bold" title="Delete row">
                                Ã—
                              </button>
                            </div>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          ))
        )}
      </div>

      <div className="bg-white border-t border-gray-300 px-2 py-1 text-xs text-gray-600">
        {officeReady ? "âœ“ Ready" : "âš  Loading..."} â€¢ 
        {filteredComments.length} comment{filteredComments.length !== 1 ? 's' : ''} â€¢ 
        Data stored in Word comments â€¢ Click cells to mark as implemented (green)
      </div>
    </div>
  );
}

ReactDOM.render(<CommentViewer />, document.getElementById('root'));
</script>
</body>
</html>
